#! /usr/bin/env python
# -*- coding: utf_8 -*-
# The exploit is a part of EAST Framework - use only under the license agreement specified in LICENSE.txt in your EAST Framework distribution

import sys
import socket
import threading
from collections import OrderedDict

sys.path.append('./core')
from Sploit import Sploit

INFO = {}
INFO['NAME'] = "fake_ftp_server"
INFO['DESCRIPTION'] = "Fake FTP Server"
INFO['VENDOR'] = "https://eastfw.com"
INFO['DOWNLOAD_LINK'] = 'https://github.com/C0reL0ader/EaST'
INFO['LINKS'] = ['']
INFO["CVE Name"] = ''
INFO["NOTES"] = """This tool used to make fake FTP server.
"""

INFO['CHANGELOG'] = "14 Dec, 2017. Written by East team"
INFO['PATH'] = 'Tools/'

OPTIONS = OrderedDict()
OPTIONS['PORT'] = 21

class exploit(Sploit):
    def __init__(self, host = "", port = 0, logger = None):
        Sploit.__init__(self, logger = logger)
        self.name = INFO['NAME']
        self.port = port
        
    def args(self):
        self.args = Sploit.args(self, OPTIONS)
        self.port = int(self.args.get('PORT', 21))

    def run(self):
        self.args()
        self.log('FTP Server port: ' + str(self.port))

        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        try:
            s.bind(('0.0.0.0', self.port))
        except Exception as e:
            self.log('Port already used')
            self.finish(False)
        s.listen(100)
        self.log('Listening on 0.0.0.0:' + str(self.port))
        self.log('Server started')
        while True:
            client, address = s.accept()
            connection = FakeFTPConnection(client, address, self.log)
            connection.daemon = True
            connection.start()

        self.finish(True)

class FakeFTPConnection(threading.Thread):
    BANNER = 'Welcome to EaST FTP Server v.0.1\r\n'
    MSG_200 = '200 OK.\r\n'
    MSG_220 = '220 ' + BANNER
    MSG_221 = '221 Goodbye.\r\n'
    MSG_331 = '331 OK\r\n'
    MSG_451 = '451 Sorry.\r\n'
    MSG_500 = '500 command not recognized\r\n'
    MSG_530 = '530 Incorrect.\r\n'

    def __init__(self, sock, addr, log):
        self.sock = sock
        self.addr = addr[0]
        self.log = log
        threading.Thread.__init__(self)

    def run(self):
        self.log(self.addr + ' connected!')
        self.sock.sendall(self.MSG_220)
        while True:
            try:
                data = self.sock.recv(256)
                if not data:
                    self.sock.close()
                    self.log(self.addr + ' disconnected!')
                    break
                f = getattr(self, data[:4].strip().upper())
                f(data)
            except AttributeError as ae:
                self.log(data)
                self.sock.sendall(self.MSG_500)
            except socket.error as se:
                break

    def USER(self, data):
        self.log('[+]RECEIVED USERNAME:' + data[4:])
        self.sock.sendall(self.MSG_331)

    def PASS(self, data):
        self.log('[+]RECEIVED PASSWORD:' + data[4:])
        self.sock.send(self.MSG_530)

    def OPTS(self, data):
        if data[5:-2].upper() == 'UTF8 ON':
            self.sock.send(self.MSG_200)
        else:
            self.sock.send(self.MSG_451)

    def QUIT(self,cmd):
        self.sock.send(self.MSG_221)
        self.sock.close()
        self.log(self.addr + ' disconnected!')
        
if __name__ == '__main__':
    """
        By now we only have the tool mode for exploit..
        Later we would have standalone mode also.
    """

    print "Running exploit %s .. " % INFO['NAME']
    e = exploit('', 80)
    e.run()
